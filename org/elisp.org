#+DATE: <2021-03-05 Fri 09:15>
#+TITLE: Elisp

An excerpt from XahLee's [[http://ergoemacs.org/emacs/elisp.html][Practical Emacs Lisp]] .

** Intro

Here just some fragment that help me to remind relative aspects. And you want know more, please learn from XahLee's [[http://ergoemacs.org/emacs/elisp.html][Practical Emacs Lisp]] .

** Emacs Lisp Basics

*** Evaluate and Help

How to evaluate elisp code?

| Command        | Key     |
|----------------+---------|
| eval-last-sexp | C-x C-e |
| eval-region    |         |
| eval-buffer    |         |

To find the doc string of a function, run =describe-function <C-h f>=.

*** Printing

#+BEGIN_SRC elisp -n
  ; printing
  (message "Hello world!")                ; "Hello world!"
#+END_SRC

You can see the output in the buffer named =*Messages*=. You can switch to it by =view-echo-area-messages <C-h e>= .

[see [[http://ergoemacs.org/emacs/elisp_printing.html][Elisp: Print, Output]]]

[see [[http://ergoemacs.org/emacs/elisp_format.html][Elisp: Format String]]]

*** Arithmetic

#+BEGIN_SRC elisp -n
  ;; 3. is a integer, 3.0 is a float
  (integerp 3.)                           ;  t
  (floatp 3.)                             ;  nil
  (floatp 3.0)                            ;  t
#+END_SRC

Function names that end with a *"p"* often means it return either true of false. (The "p" stands for *"predicate"*) =t= means true, =nil= means false.

*Convert String and Number*

#+BEGIN_SRC elisp -n
  (string-to-number "3")
  (number-to-string 3)
#+END_SRC

*** True, Flase

*There is no "boolean datatype" in elisp.* Just remember that =nil= and empty list =()= are false, anything else is true.

*Boolean Functions*

#+BEGIN_SRC elisp -n
  ;; Comparing numbers
  ;; < > <= >= = /=
  (= 3 3)                                 ;  t
  (= 3 3.00000000000000001)               ;  t

  (/= 3 4)                                ; not equal. ⇒ t
#+END_SRC

*Tips: ~=~ is used to compare numbers but not assign.

For generic equality test, use =equal=. It test if two values have the same *datatype* and *value*.

There's alse the function =eq=, it returns =t= if the two args are the same *Lisp object*. This is usually not what you want. e.g. =(eq "e" "e")= returns =nil=.

To test for inequality, the ~/=~ is for numbers only, and doesn't work for strings and other lisp data. Use =not= to negate your equality test.

*** Variables

**** Global Variables

=setq= is used to set variables. Variables need not be declared, and is global.

#+BEGIN_SRC elisp -n
  (setq x 1)                              ; assign 1 to x
  (setq a 3 b 2 c 7)                      ; multiple assignment
#+END_SRC

**** Local Variables

To define local variables, use =let=. The form is:

#+BEGIN_SRC elisp -n
  ;; (let  (var1 var2 ...) body)
  (let (a b)
   (setq a 3)
   (setq b 4)
   (+ a b)
   )                                      ;  7

  ;; (let ((var1 val1) (var2 val2) …) body)
  ;; This form is convenient if you just have a few simle local vars with known values.
  (let ((a 3) (b 4))
   (+ a b)
  )                                       ;  7
#+END_SRC

Where =body= is (onre or more) lisp expressions. The body's last expression's value is returned.

[REF [[http://ergoemacs.org/emacs_manual/elisp/Variables.html][(info "(elisp) Variables")]]]

*** If Then Else

The form for "if" expression is:

#+BEGIN_SRC elisp -n
  ;; (if test body)
  ;; or
  ;; (if test true_body false_body)
  ;; and if no flase expression, return nil. e.g.
  (if (< 3 2) (message "yes"))            ; nil
#+END_SRC

[REF [[http://ergoemacs.org/emacs_manual/elisp/Control-Structures.html][(info "(elisp) Control Structures")]]]

If you do not need a "else" part, you should use the function =when= instead, because it is more clear. The form is:

#+BEGIN_SRC elisp -n
  ;; (when test expr1 expr2 ...)
  ;; Its meaning is the same as
  ;; (if test (progn expr1 expr2 ...))
#+END_SRC

*Block of Expressions*

Sometimes you need to group several expressions together as one single expression. This can be done with =progn=.

The purpose of =(progn ...)= is similar to a block of code ={...}= in C-like languages. =progn= returns the last expression in its body.

*** Loop

Most basic loop in elisp is with =(while test body)=, where =body= is one or more lisp expressions.

#+BEGIN_SRC elisp -n
(setq x 0)

(while (< x 4)
  (print (format "number is %d" x))
  (setq x (1+ x)))
#+END_SRC

Usually it's better to use =dolist= or =dotimes= .

[see [[http://ergoemacs.org/emacs/elisp_mapcar_loop.html][Elisp: Map List/Vector]]]

[REF [[http://ergoemacs.org/emacs_manual/elisp/Iteration.html][(info "(elisp) Iteration")]]]

[see [[http://ergoemacs.org/emacs/elisp_break_loop.html][Elisp: throw, catch]]]

*** Sequence, List, Vector

Here's a chart of elisp's most important list-like datatypes.

#+BEGIN_EXPORT html
<img
src="images/elisp-1.svg"
width="360"
height=""
style=""
title=""
/>
#+END_EXPORT

*Tips: "Sequence" and "Array" are note actual datatypes in elisp. They are grouping names for other actual datatypes.

When a function's doc says that an argument is a sequence type, it means that it can be list, vector, or string. (e.g. =mapcar=).

When a function's doc says an argument is a array type, it means that it can be vectory or string. (e.g. =aref=)

List and Vector both hold a ordered sequence of values, each value can be any type.

*Differences Between List and Vector*

Here's the primary differences between list and vector:
- Vector, access time to any element is constant.
- Vector's length cannot change. If you create a new copy of a vector, the time required is proportional to the vector's length.
- List, access time to a element is proportional to the distance of the element's position in the list.
- List's length can grow by prepending element, and can shorten by rempoving first element. These operations have constant time.

We will learn more at [[*Lisp Data Structure][Lisp Data Structure]].

*** Define a Function or Command

Basic function definition is of the form:

#+BEGIN_SRC elisp -n
  ;; (defun function_name (param1 param2 ...) "doc_string" body)
  (defun myFunction ()
    "testing"
    ;; (interactive)
    (message "Yay!"))
#+END_SRC

When a function is called, the last expression in the function's definition body is returned. (there's no "return statement".)

[REF [[http://ergoemacs.org/emacs_manual/elisp/Defining-Functions.html][(info "(elisp) Defining Functions")]]]

When a function is also a command, we say that the function is avilable for interactive use.

To make a function availiable for interactive use, add =(interactive)= right after the "doc string". Evaluate the following code. Then, you can call it by =execute-extended-command=.

[REF [[http://ergoemacs.org/emacs_manual/elisp/Defining-Commands.html][(info "(elisp) Defining Commands")]]]

Here is a function definition template that majority of elisp commands follow:

#+BEGIN_SRC elisp -n
  (defun myCommand ()
    "One sentence summary of what this command do.

  More detailed documentation here."
    (interactive)
    (let (localVar1 localVar2 ...)
      ; do somethins here...
      ; ...
      ; last expression is returned
      ))
#+END_SRC

[see [[http://ergoemacs.org/emacs/elisp_optional_params.html][Elisp: Function Optional Parameters]]]

[see [[http://ergoemacs.org/emacs/inline_doc.html][Elisp: Doc String Markup]]]

** Lisp Data Structure

*** List

Emacs Lisp's list datatype is known as linked list in computer science.

**** Create List

