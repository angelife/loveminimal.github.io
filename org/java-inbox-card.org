#+DATE: <2021-04-04 Sun 17:23>
#+TITLE: Java Inbox

→ 摘录自廖雪峰老师的 https://www.liaoxuefeng.com/wiki/1252599548343744

* 面向对象

** 模块

*为什么需要模块？*

=.class= 文件是 JVM 看到的最小可执行文件，jar 是用于存放 class 的容器，它并不关心 class 之间的依赖。

从Java 9开始引入了自带“依赖关系”的 class 容器 -- *模块* 。

*如何编写模块呢？*

#+BEGIN_EXPORT html
<img
src="images/java-42.png"
width="660"
height=""
style=""
title=""
/>
#+END_EXPORT

仅仅在 =src= 目录下多了一个 =module-info.java= 这个文件，这就是模块的描述文件。如：

#+BEGIN_SRC java -n
module hello.world {
	requires java.base; // 可不写，任何模块都会自动引入java.base
	requires java.xml;
}
#+END_SRC

*当我们使用模块声明了依赖关系后，才能使用引入的模块。

*模块有什么用？*

我们可以用它来打包 JRE ！

模块进一步隔离了代码的访问权限，只有它声明的导出的包，外部代码才被允许访问。

* 反射

反射就是 Reflection， Java 的反射是指程序在运行期（对某个实例一无所知的情况下）可以拿到一个对象的所有信息。

** Class 类

除了 =int= 等基本类型外，Java 的其他类型全部都是 =class= （包括 =interface= ）。

=class= 是由 JVM 在执行过程中动态加载的。 JVM 在第一次读取到一种 =class= 类型时，将其加载进内存。

*每加载一种 =class= ，JVM 就为其创建一个 =Class= 类型的实例，* 并关联进来。
这里的 =Class= 类型是一个名叫 "Class" 的 =class= 。它长这样：

#+BEGIN_SRC java -n
  public final class Class {
      private Class() {}
  }
#+END_SRC

这个 =Class= 实例是 JVM 内部创建的，可以发现 =Class= 类的构造方法是 =private= ，只有 JVM 能创建 =Class= 实例，我们自己的 Java 程序是无法创建 =Class= 实例的。

**JVM持有的每个 =Class= 实例都指向一个数据类型（ =class= 或 =interface= ）。*

一个 =Class= 实例包含了该 =class= 的所有完整信息：

#+BEGIN_EXPORT html
<img
src="images/java-50.jpg"
width="420"
height=""
style=""
title=""
/>
#+END_EXPORT

由于 JVM 为每个加载的 =class= 创建了对应的 =Class= 实例，并在实例中保存了该 =class= 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 =Class= 实例，我们就可以通过这个 =Class= 实例获取到该实例对应的 =class= 的所有信息。

#+BEGIN_QUOTE
这种通过 =Class= 实例获取 =class= 信息的方法称为反射 （Reflection）。
#+END_QUOTE

如何获取一个 =class= 的 =Class= 实例？有三个方法：
1. 直接通过一个 =class= 的静态变量 =class= 获取；
2. 通过实例变量（如果有）提供的 =getClass()= 方法获取；
3. 如果知道一个 =class= 的完整类名，通过静态方法 =Class.forName()= 获取。

#+BEGIN_SRC java -n
  // 1
  Class cls = String.class;
  // 2
  String s = "Hello";
  Class cls = s.getClass();
  // 3
  Class cls = Class.forName("java.lang.String");
#+END_SRC

=Class= 实例在 JVM 中是唯一的，所以，上述方法获取的 =Class= 实例是同一个实例。

JVM 为每一种基本类型如 =int= 也创建了 =Class= ，通过 =int.class= 访问。

JVM 总是动态加载 =class= ，可以在运行期根据条件来控制加载 =class= 。

* Maven

Maven 是一个 Java 项目管理和构建工具，它可以定义 _项目结构_ 、 _项目依赖_ ，并且用统一的方式进行 _自动化构建_ （编译、测试、打包、发布……）。

#+BEGIN_EXPORT html
<div class="org-essay">
在标准化这件事上，真是你好、我好、大家好！
</div>
#+END_EXPORT

** 为什么需要 Maven

一个 Java 项目需要什么？

首先，确定 *目录结构* 。

其次，我们需要确定 *引入哪些依赖包* ，并把它们加入 classpath 。

此外，还需要配置环境，例如 JDK 的版本，编译打包的流程，当前代码的版本号。

如果你不使用 IDE ，那么我们就不得不使用命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。

这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。

#+BEGIN_EXPORT html
<div class="org-essay">
哎，多项目，不标准化，真的是一言难尽……
</div>
#+END_EXPORT

** Maven 项目结构

#+BEGIN_EXPORT html
<img
src="images/java-47.jpg"
width="200"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

项目的根目录 =a-maven-project= 是项目名，它有一个项目描述文件 =pom.xml= ，存放 Java 源码的目录是 =src/main/java= ，存放资源文件的目录是 =src/main/resources= ，存放测试源码的目录是 =src/test/java= ，存放资源的目录是 =src/test/resources= ，最后，所有编译、打包生成的文件都放在 =target= 目录里。

所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven 就可以正常使用。

#+BEGIN_EXPORT html
<div class="org-essay">
确定的目录结构，对于 Maven 来说也是必须的，因为实现 Maven 这个工具本身也需要按照相对确定的路径来扫描所要使用的文件。
</div>
#+END_EXPORT

** 项目描述文件

POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个 XML 文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。

执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。

*所有 POM 文件都需要 =project= 元素和三个必需字段： =groupId，artifactId，version= 。*

#+BEGIN_SRC xml -n
  <project xmlns = "http://maven.apache.org/POM/4.0.0"
      xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation = "http://maven.apache.org/POM/4.0.0
      http://maven.apache.org/xsd/maven-4.0.0.xsd">

      <!-- 模型版本 -->
      <modelVersion>4.0.0</modelVersion>
      <!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成，
           如com.companyname.project-group，
           maven会将该项目打成的jar包放本地路径：/com/companyname/project-group -->
      <groupId>com.companyname.project-group</groupId>

      <!-- 项目的唯一ID，一个groupId下面 _可能多个项目_，就是靠artifactId来区分的 -->
      <artifactId>project</artifactId>

      <!-- 版本号 -->
      <version>1.0</version>
  </project>
#+END_SRC

-----
*Super POM*

所有的 POM 都继承自一个 *父 POM（Super POM）* （无论是否显式定义了这个父 POM）。

父 POM 包含了一些可以被继承的默认设置，使用 =mvn help:effective-pom= 命令来查看 Super POM 默认配置。

#+BEGIN_QUOTE
Maven 使用 =effective pom= （Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 =pom.xml= 中做尽可能少的配置，当然这些配置可以被重写。
#+END_QUOTE

你可以看到 Maven 在执行目标时需要用到的默认工程源码目录结构、输出目录、需要的插件、仓库和报表目录。

详细的 =pom.xml= 配置请查看 https://www.runoob.com/maven/maven-pom.html

-----
*Maven 依赖*

#+BEGIN_SRC xml -n
<project...>
    ...
    <dependencies>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
        ...
    </dependencies>
</project>
#+END_SRC

使用 =<dependency>= 声明一个依赖后，Maven 就会自动下载这个依赖包并把它放到 classpath 中。 Maven使用 =groupId，artifactId= 和 =version= 唯一定位一个依赖。

** 依赖管理

Maven 的第一个作用就是解决依赖管理。我们声明了自己的项目需要 =abc= ，Maven会自动导入 =abc= 的 jar包，再判断出 =abc= 需要 =xyz= ，又会自动导入 =xyz= 的jar包 ……

如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。

*依赖关系*

Maven定义了几种依赖关系，分别是 =compile、test、runtime= 和 =provided= 。

默认的 =compile= 是最常用的，Maven会把这种类型的依赖直接放入 classpath 。

=test= 依赖表示仅在测试时使用，正常运行时并不需要，如 JUnit 。

=runtime= 依赖表示编译时不需要，但运行时需要。最典型的 =runtime= 依赖是 JDBC 驱动，例如 MySQL驱动。

=provided= 依赖表示编译时需要，但运行时不需要。最典型的 =provided= 依赖是 =Servlet API= ，编译的时候需要，但是运行时，Servlet服务器内置了相关的 jar，所以运行期不需要。

#+BEGIN_EXPORT html
<div class="org-essay">
比如，运行的时候，Servlet 容器 Tomcat 会提供相关的 Servlet API 。
</div>
#+END_EXPORT

*搜索第三方组件*

通过 [[https://search.maven.org/][search.maven.org]] 搜索关键字，找到对应的组件后，直接复制。

** Maven 镜像

中国区用户可以使用阿里云提供的 Maven 镜像仓库。使用 Maven 镜像仓库需要一个配置，在用户主目录下进入 =.m2= 目录，创建一个 =settings.xml= 配置文件，内容如下：

#+BEGIN_SRC xml -n
<settings>
    <mirrors>
        <mirror>
            <id>aliyun</id>
            <name>aliyun</name>
            <mirrorOf>central</mirrorOf>
            <!-- 国内推荐阿里云的Maven镜像 -->
            <url>https://maven.aliyun.com/repository/central</url>
        </mirror>
    </mirrors>
</settings>
#+END_SRC

** TODO 构建流程

……

* TODO 多线程

** 线程和进程

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

#+BEGIN_EXPORT html
<img
src="images/java-43.jpg"
width="660"
height=""
style=""
title=""
/>
#+END_EXPORT

操作系统调度的最小任务单位其实不是进程，而是线程。

相对进程来说，创建线程开销小、通信快（线程间通信就是读写同一个变量）。多进程的好处在于稳定性好，一个进程崩溃不会影响其他进程。

Java 语言内置了多线程的支持：一个 Java 程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行 =main()= 方法，在 =main()= 方法内部，我们又可以启动多个线程。此外，JVM 还有负责垃圾回收的其他工作线程等。

因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。

Java多线程编程的特点又在于：

- 多线程模型是Java程序最基本的并发模型；
- 后续读写网络、数据库、Web开发等都依赖Java多线程模型。

** 创建新线程

要创建一个新线程非常容易，我们需要实例化一个 =Thread= 实例，然后调用它的 =start()= 方法：

#+BEGIN_SRC java -n
public class Main {
    public static void main(String[] args) {
        Thread t = new Thread();
        t.start(); // 启动新线程
    }
}
#+END_SRC

但是这个线程启动后实际上什么也不做就立刻结束了。

我们希望新线程能执行指定的代码，有以下几种方法：

1) 从 =Thread= 派生一个自定义类，然后覆写 =run()= 方法；
2) 创建 =Thread= 实例时，传入一个 =Runnable= 实例；
3) 或用Java8引入的 lambda语法。

#+BEGIN_QUOTE
小结：
- Java用 =Thread= 对象表示一个线程，通过调用 =start()= 启动一个新线程；
- 一个线程对象只能调用一次 =start()= 方法；
- 线程的执行代码写在 =run()= 方法中；
- 线程调度由操作系统决定，程序本身无法决定调度顺序。
#+END_QUOTE

** 线程的状态

在Java程序中，一个线程对象只能调用一次 =start()= 方法启动新线程，并在新线程中执行 =run()= 方法。一旦 =run()= 方法执行完毕，线程就结束了。

#+BEGIN_EXPORT html
<img
src="images/java-44.jpg"
width="300"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

如图所示，Java线程的状态有以下几种：

- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在执行 =run()= 方法的Java代码；
- Blocked：运行中的线程，因为某些操作被阻塞而挂起；
- Waiting：运行中的线程，因为某些操作在等待中；
- Timed Waiting：运行中的线程，因为执行 =sleep()= 方法正在计时等待；
- Terminated：线程已终止，因为 =run()= 方法执行完毕。

当线程启动后，它可以在 =Runnable、Blocked、Waiting= 和 =Timed Waiting= 这几个状态之间切换，直到最后变成 =Terminated= 状态，线程终止。

线程终止的原因有：

- 线程正常终止： =run()= 方法执行到return语句返回；
- 线程意外终止： =run()= 方法因为未捕获的异常导致线程终止；
- 对某个线程的 Thread实例调用 =stop()= 方法强制终止（强烈不推荐使用）。

通过对另一个线程对象调用 =join()= 方法可以等待其执行结束,对已经运行结束的线程调用 =join()= 方法会立刻返回。

** 中断线程

=main= 线程通过调用 =t.interrupt()= 方法中断 =t= 线程，但是要注意， =interrupt()= 方法仅仅向 =t= 线程发出了“中断请求”，至于 =t= 线程是否能立刻响应，要看具体代码。

#+BEGIN_QUOTE
小结：

对目标线程调用 =interrupt()= 方法可以请求中断一个线程，目标线程通过检测 =isInterrupted()= 标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到 =InterruptedException= ；

目标线程检测到 =isInterrupted()= 为 =true= 或者捕获了 =InterruptedException= 都应该立刻结束自身线程；

通过标志位判断需要正确使用 =volatile= 关键字；=volatile= 关键字解决了共享变量在线程间的可见性问题。
#+END_QUOTE

** 守护进程

守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。

如何创建守护线程呢？方法和普通线程一样，只是在调用 =start()= 方法前，调用 =setDaemon(true)= 该线程标记为守护线程：

#+BEGIN_SRC java -n
Thread t = new MyThread();
t.setDaemon(true);
t.start();
#+END_SRC

在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

** 线程同步

当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。

多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以 *原子方式* 执行：即某一个线程执行时，其他线程必须等待。

#+BEGIN_QUOTE
**原子操作是指不能被中断的一个或一系列操作。*
#+END_QUOTE

如，对于语句 =n = n + 1;= ，看上去是一行语句，实际上对应了 3 条指令：

#+BEGIN_EXAMPLE
ILOAD
IADD
ISTORE
#+END_EXAMPLE

#+BEGIN_EXPORT html
<img
src="images/java-45.jpg"
width="260"
height=""
style=""
title=""
/>
#+END_EXPORT

✘

#+BEGIN_EXPORT html
<img
src="images/java-46.jpg"
width="260"
height=""
style=""
title=""
/>
#+END_EXPORT

✔

通过加锁和解锁的操作，就能保证 3 条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。

即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 _*临界区* （Critical Section）_ ，任何时候临界区最多只有一个线程能执行。

*可见，保证一段代码的原子性就是通过加锁和解锁实现的。*

Java程序使用 =synchronized= 关键字对一个对象进行加锁， =synchronized= 保证了代码块在任意时刻最多只有一个线程能执行。

如何使用 =synchronized= ：

- 找出修改共享变量的线程代码块；
- 选择一个共享实例作为锁；
- 使用 =synchronized(lockObject) { ... }= 。

*因为 =synchronized= 代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以， =synchronized= 会降低程序的执行效率。

JVM 只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。因此，使用 =synchronized= 的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。

#+BEGIN_QUOTE
小结：

- 多线程同时读写共享变量时，会造成逻辑错误，因此需要通过 =synchronized= 同步；
- 同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；
- 注意加锁对象必须是同一个实例；
- 对 JVM 定义的单个原子操作不需要同步。
#+END_QUOTE

** 同步方法

让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装，更好的方法是把 =synchronized= 逻辑封装起来。如下：

#+BEGIN_SRC java -n
public class Counter {
    private int count = 0;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }

    public void dec(int n) {
        synchronized(this) {
            count -= n;
        }
    }

    public int get() {
        return count;
    }
}
#+END_SRC

如此，线程调用 =add()= 、 =dec()= 方法时，它不必关心同步逻辑，因为 =synchronized= 代码块在 =add()= 、 =dec()= 方法内部。并且， =synchronized= 锁住的对象是 =this= ，即当前实例，这又使得创建多个 =Counter= 实例的时候，它们之间互不影响，可以并发执行。

如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。

*没有特殊说明时，一个类默认是非线程安全的。

当我们锁住的是 =this= 实例时，实际上可以用 =synchronized= 修饰这个方法。下面两种写法是等价的：

#+BEGIN_SRC java -n
  public void add(int n) {
      synchronized(this) { // 锁住this
          count += n;
      } // 解锁
  }

  // 等价于

  public synchronized void add(int n) { // 锁住this
      count += n;
  } // 解锁
#+END_SRC

*因此，用 =synchronized= 修饰的方法就是同步方法，它表示整个方法都必须用 =this= 实例加锁。*

* JDBC 编程

Java 为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity 。

** 关系数据库

程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。

如何定义数据的存储格式就是一个大问题！

为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。

-----
*JDBC*

什么是 JDBC？JDBC 是 Java DataBase Connectivity 的缩写，它是 Java 程序访问数据库的标准接口。

使用 Java 程序访问数据库时，Java 代码并不直接通过 TCP 连接去访问数据库，而是通过 JDBC 接口来访问，而 JDBC 接口则通过 JDBC 驱动来实现真正对数据库的访问。

#+BEGIN_QUOTE
*JDBC 接口是 Java 标准库自带的，所以可以直接编译。而具体的 JDBC 驱动是由数据库厂商提供的，不同厂商提供的 JDBC 驱动都是标准的。
#+END_QUOTE

从代码来看，Java 标准库自带的 JDBC 接口其实就是定义了一组接口（在标准库 =java.sql= 中），而某个具体的 JDBC 驱动其实就是实现了这些接口的类：

#+BEGIN_EXPORT html
<img
src="images/java-51.jpg"
width="260"
height=""
style=""
title=""
/>
#+END_EXPORT

实际上，一个 MySQL 的 JDBC 的驱动就是一个 jar 包，它本身也是纯 Java 编写的。

** JDBC 操作

*1.JDBC连接*

使用 JDBC 时，我们先了解什么是 Connection ？

Connection 代表一个 JDBC 连接，它相当于 Java 程序到数据库的连接（通常是 TCP 连接）。打开一个 Connection 时，需要准备 URL、用户名和口令，才能成功连接到数据库。

URL 是由数据库厂商指定的格式，例如，MySQL 的 URL 是：

#+BEGIN_EXAMPLE
jdbc:mysql://<hostname>:<port>/<db>?key1=value1&key2=value2

# 假设数据库运行在本机 localhost，
# 端口使用标准的3306，数据库名称是learnjdbc，那么URL如下：
jdbc:mysql://localhost:3306/learnjdbc?useSSL=false&characterEncoding=utf8
# 后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码
#+END_EXAMPLE

要获取数据库连接，使用如下代码：

#+BEGIN_SRC java -n
  // JDBC连接的URL, 不同数据库有不同的格式:
  String JDBC_URL = "jdbc:mysql://localhost:3306/test";
  String JDBC_USER = "root";
  String JDBC_PASSWORD = "password";
  // 获取连接：
  Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
  // TODO: 访问数据库...
  // ...

  // 关闭连接
  conn.close();
#+END_SRC

核心代码是 =DriverManager= 提供的静态方法 =getConnection()= 。 =DriverManager= 会自动扫描 classpath，找到所有的 JDBC 驱动，然后根据我们传入的 =URL= 自动挑选一个合适的驱动。

-----
*2.JDBC 查询*

通过 =Connection= 提供的 =createStatement()= 方法创建一个 =Statement= 对象，用于执行一个查询。

使用 =Statement= 拼字符串非常容易引发 SQL 注入的问题，这是因为 SQL 参数往往是从方法参数传入的。

使用 =PreparedStatement= 可以完全避免SQL注入的问题，且更快、更安全。

#+BEGIN_QUOTE
*使用 Java 对数据库进行操作时，必须使用 =PreparedStatement= ，严禁任何通过参数拼字符串的代码！*
#+END_QUOTE

查询结果总是 =ResultSet= ，即使使用聚合查询也不例外。

-----
后续插入、更新、删除，本质上也是用 =PreparedStatement= 执行一条 SQL 语句，不过最后执行的不是 =executeQuery()= ，而是 =executeUpdate()= 。

** JDBC 事务

数据库事务（Transaction）是由若干个 SQL 语句构成的一个操作序列，数据库系统保证在一个事务中的所有 SQL 要么全部执行成功，要么全部不执行。

对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。

JDBC 提供了事务的支持，使用 Connection 可以开启、提交或回滚事务。要在 JDBC 中执行事务，本质上就是如何把多条 SQL 包裹在一个数据库事务中执行。

** JDBC Batch

使用 JDBC 操作数据库的时候，经常会执行一些批量操作。

通过一个循环来执行每个 =PreparedStatement= 虽然可行，但是性能很低。SQL 数据库对 SQL 语句相同，但 *只有参数不同的若干语句* 可以作为 batch 执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个 SQL。

使用 JDBC 的 batch 操作会大大提高执行效率，对内容相同，参数不同的 SQL，要优先考虑 batch 操作。

** JDBC 连接池

为了避免频繁地创建和销毁 JDBC 连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。

JDBC 连接池有一个标准的接口 =javax.sql.DataSource= ，注意这个类位于 Java 标准库中，但仅仅是接口。要使用 JDBC 连接池，我们必须选择一个 JDBC 连接池的实现。

目前使用最广泛的是 HikariCP。

连接池内部维护了若干个 =Connection= 实例，如果调用 =ds.getConnection()= ，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对 =Connection= 调用 =close()= ，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的 SQL 语句。

* Web 开发

** JavaEE

JavaEE 是完全基于JavaSE，只是多了一大堆服务器相关的库以及 API 接口。所有的 JavaEE 程序，仍然是运行在标准的 JavaSE 的虚拟机上的。

JavaEE 并不是一个软件产品，它更多的是一种软件架构和设计思想。我们可以把 JavaEE 看作是在 JavaSE 的基础上，开发的一系列基于服务器的组件、API标准和通用架构。

#+BEGIN_EXPORT html
<img
src="images/java-48.jpg"
width="120"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

*JavaEE 最核心的组件就是基于 Servlet标准的Web服务器* （如 Tomcat），开发者编写的应用程序是基于 Servlet API 并运行在 Web服务器内部的。

目前流行的基于 Spring 的轻量级 JavaEE 开发架构，使用最广泛的是 Servlet 和 JMS ，以及一系列开源组件。

** Web 基础

*HTTP 协议（需要单独深入一下）*

HTTP 协议是一个基于 TCP 协议之上的请求-响应协议。

通常浏览器获取的 *第一个资源* 是 HTML 网页，在网页中，如果嵌入了 JavaScript、 CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。

如何编写 HTTP Server ？

一个 HTTP Server 本质上是一个 TCP 服务器，我们可以用 TCP 编程的多线程来实现一个服务器端框架。

** Servlet

我们看到，编写 HTTP 服务器其实是非常简单的，只需要先编写基于多线程的 TCP 服务，然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可。

但是，要编写一个完善的HTTP服务器，需要考虑好多方面，经过长期测试才能稳定运行。

因此，在 JavaEE 平台上，处理 TCP 连接，解析 HTTP 协议这些底层工作统统扔给现成的 Web 服务器去做，我们只需要把自己的应用程序跑在 Web 服务器上。

为了实现这一目的， *JavaEE 提供了 Servlet API* ， *Web 服务器实现 Servlet API 接口* ，实现底层功能。 *我们使用 Servlet API 编写自己的 Servlet* 来处理 HTTP 请求。

一个 Servlet 总是继承自 =HttpServlet= ，然后覆写 =doGet()= 或 =doPost()= 方法。它们接收 =HttpServletRequest= 和 =HttpServletResponse= 两个对象做为参数，分别代表 HTTP 请求和响应。

我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 =HttpServletRequest= 和 =HttpServletResponse= 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 =PrintWriter= ，写入响应即可。

*Servlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。*

看一下伪示例的 =pom.xml= 文件如下：

#+BEGIN_SRC xml -n
  <project...>
      ...
      <packaging>war</packaging>
      ...

      <dependencies>
          <dependency>
              <groupId>javax.servlet</groupId>
              <artifactId>javax.servlet-api</artifactId>
              <version>4.0.0</version>
              <scope>provided</scope>
          </dependency>
      </dependencies>
      ...
  </project>
#+END_SRC

注意 =<packaging>war</packaging>= ，打包的类型不是 =jar= ，而是 =war= ； =<scope>= 指定为 =provided= ，表示编译时使用，但不会打包到 =.war= 文件中，因为运行期 Web 服务器本身已经提供了 Servlet API 相关的 jar 包。

-----
*web.xml*

我们还需要在工程目录下创建一个 =web.xml= 描述文件，放到 =src/main/webapp/WEB-INF= 目录下（固定目录结构，不要修改路径，注意大小写）。如：

#+BEGIN_EXPORT html
<img
src="images/java-49.jpg"
width="430"
height=""
style=""
title=""
/>
#+END_EXPORT

运行 Maven 命令 =mvn clean package= ，在 =target= 目录下得到一个 =hello.war= 文件，这个文件就是我们编译打包后的 Web 应用程序。

-----
*我们应该如何运行这个 =war= 文件？*

普通的 Java 程序是通过启动 JVM，然后执行 =main()= 方法开始运行。 但是 Web 应用程序有所不同， *我们无法直接运行 =war= 文件* ，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 =HelloServlet= ，这样就可以让 =HelloServlet= 处理浏览器发送的请求。

因此，我们首先要找一个支持 Servlet API 的 Web 服务器。常用的服务器有：

- Tomcat：由Apache开发的开源免费服务器；
- Jetty：由Eclipse开发的开源免费服务器；
- GlassFish：一个开源的全功能JavaEE服务器。

无论使用哪个服务器，只要它支持 Servlet API 4.0（因为我们引入的Servlet版本是4.0），我们的 war 包都可以在上面运行。

#+BEGIN_QUOTE
实际上，类似 Tomcat 这样的服务器也是 Java 编写的，启动 Tomcat 服务器实际上是启动 Java 虚拟机，执行 Tomcat 的 =main()= 方法，然后由 Tomcat 负责加载我们的 =.war= 文件，并创建一个 =HelloServlet= 实例，最后以多线程的模式来处理 HTTP 请求。
#+END_QUOTE

因为我们编写的 Servlet 并不是直接运行，而是由 Web 服务器加载后创建实例运行，所以，类似 Tomcat 这样的 Web 服务器也称为 _Servlet 容器_ 。

在 Servlet 容器中运行的 Servlet 具有如下特点：

- 无法在代码中直接通过 =new= 创建 =Servlet= 实例，必须由 Servlet 容器自动创建 Servlet 实例；
- Servlet 容器只会给每个 Servlet 类创建唯一实例；
- Servlet 容器会使用多线程执行 =doGet()= 或 =doPost()= 方法。
- ……
- 在 Servlet 中定义的实例变量会被多个线程同时访问，要注意线程安全；
-  =HttpServletRequest= 和 =HttpServletResponse= 实例是由 Servlet 容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；
- 在 =doGet()= 或 =doPost()= 方法中，如果使用了 ThreadLocal，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为 Servlet 容器很可能用线程池实现线程复用。

因此，正确编写 Servlet，要清晰理解 Java 的多线程模型，需要同步访问的必须同步。

** Servlet 开发

一个完整的 Web 应用程序的开发流程如下：

- 编写 Servlet；
- 打包为 war 文件；
- 复制到 Tomcat 的 webapps 目录下；
- 启动 Tomcat。

许多初学者经常卡在如何在 IDE 中启动 Tomcat 并加载 webapp，更不要说断点调试了……

……

因为 Tomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：

- 启动 JVM 并执行 Tomcat 的 =main()= 方法；
- 加载 war 并初始化 Servlet；
- 正常服务。

启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 =main()= 方法，我们完全可以 *把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 =main()= 方法* ，先启动 Tomcat，然后让它加载我们的 webapp 就行。

#+BEGIN_QUOTE
现在好了，SpringBoot 支持在 =main()= 方法中一行代码直接启动 Tomcat 。
#+END_QUOTE

*开发 Servlet 时，推荐使用 =main()= 方法启动嵌入式 Tomcat 服务器并加载当前工程的 webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。

* Spring 开发

** AOP 本质

  *AOP 的本质就是一个动态代理，* 让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。

  #+BEGIN_QUOTE
  需要特别指出的是，AOP 对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC 的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用 AOP 实现日志，我们只能输出固定格式的日志，因此，使用 AOP 时，必须适合特定的场景。
  #+END_QUOTE

** 装配 AOP

AOP 本质上只是一种代理模式的实现方式，在 Spring 的容器中实现 AOP 特别方便。

#+BEGIN_QUOTE
Spring 对接口类型使用 JDK 动态代理，对普通类使用 CGLIB 创建子类。如果一个 Bean 的 class 是 =final= ，Spring 将无法为其创建子类。
#+END_QUOTE

虽然 Spring 容器内部实现 AOP 的逻辑比较复杂（需要使用 AspectJ 解析注解，并通过 CGLIB 实现代理类），但我们使用 AOP 非常简单，一共需要三步：

- 定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法；
- 标记 =@Component= 和 =@Aspect= ；
- 在 =@Configuration= 类上标注 =@EnableAspectJAutoProxy= 。

使用注解实现 AOP 需要先定义注解，然后使用 =@Around("@annotation(name)")= 实现装配。

使用注解既简单，又能明确标识 AOP 装配，是使用 AOP 推荐的方式。

** AOP 避坑指南

无论是使用 AspectJ 语法，还是配合 Annotation ，使用 AOP ，实际上就是让 Spring 自动为我们创建一个 Proxy ，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑。因此， *AOP 本质上就是一个代理模式* 。

因为 Spring 使用了 CGLIB 来实现运行期动态创建 Proxy ，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。

……

#+BEGIN_EXPORT html
<div class="org-essay">
使用的过程中，慢慢埋坑吧……
</div>
#+END_EXPORT

** 访问数据库

使用 JDBC 虽然简单，但代码比较繁琐。Spring 为了简化数据库访问，主要做了以下几点工作：

- 提供了简化的访问 JDBC 的模板类，不必手动释放资源；
- 提供了一个统一的 DAO 类以实现 Data Access Object 模式；
- 把 =SQLException= 封装为 =DataAccessException= ，这个异常是一个 =RuntimeException= ，并且让我们能区分SQL异常的原因，例如， =DuplicateKeyException= 表示违反了一个唯一约束；
- 能方便地集成 Hibernate、JPA 和 MyBatis 这些数据库访问框架。

** TODO 使用 JDBC

……

小结：
- Spring 提供了 =JdbcTemplate= 来简化 JDBC 操作；
- 使用 =JdbcTemplate= 时，根据需要优先选择高级方法；
- 任何 JDBC 操作都可以使用保底的 =execute(ConnectionCallback)= 方法。

