#+DATE: <2021-03-03 Wed 10:19>
#+TITLE: 当然我在扯淡

#+BEGIN_QUOTE
我并不喜欢王垠这个人，甚至有些反感，但他的某些博文我很喜欢，也因此而受益，Hmm...
#+END_QUOTE

*Tip. 非原文摘录，各别语句进行了删减和改动，建议看原文（点击章节标题）。

** Blog Excepts

*** [[http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness][什么是“对用户友好”]]

#+BEGIN_EXPORT html
<img
src="images/yinwang-1.jpg"
width="160"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

#+BEGIN_QUOTE
Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction.

-- Albert Einstein

任何聪明的傻瓜都能把事情做得更大、更复杂、更暴力，而在相反的方向上前进则需要一点天才和很大的勇气。
#+END_QUOTE

“对用户不友好”的背后，其实是程序设计的不合理使得它们 *缺少抽象* ，而不是用户的问题。

#+BEGIN_EXPORT html
<essay>
这点确实，比如，我就总是搞不清楚冰箱中的致冷程度数字、洗衣机面板上的各种设置开关……
</essay>
#+END_EXPORT

如何对用户更加友好呢？ *统一、抽象！*

*** [[http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman][GTF - Great Teacher Friedman]]

程序语言的研究者们往往追逐一些“新概念”，却未能想到很多这些新概念早在几十年前就被 Friedman 想到了。

知识的深度是无止境的。

Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。

在 Friedman 的课上，我利用它们（如 closure 、CPS 等概念）来完成有实际意义的目标，才真正的体会到这些概念的内涵和价值。

#+BEGIN_QUOTE
一个例子就是课程进入到没几个星期的时候，我们开始 *写解释器* 来执行简单的 Scheme 程序。然后我们把这个解释器 *进行 CPS 变换* ，引入全局变量作为 *“寄存器”* (register)，把 CPS 产生的 continuation 转换成 *数据结构（也就是堆栈）* 。最后我们得到的是一个 *抽象机* (abstract machine)，而这在本质上相当于一个真实机器里的中央处理器（CPU）或者虚拟机（比如 JVM）。所以我们其实从无到有，“发明”了 CPU！从这里，我才真正的理解到寄存器，堆栈等的本质，以及我们为什么需要它们。我才真正的明白了，冯诺依曼体系构架为什么要设计成这个样子。后来他让我们去看一篇他的好朋友 Olivier Danvy 的论文，讲述如何从各种不同的解释器经过 CPS 变换得出不同种类的抽象机模型。这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到， *机器并不是计算的本质* 。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料， *我们所要表达的语义，也就是计算的本质，却是不变的。*
#+END_QUOTE

#+BEGIN_QUOTE
当然， *重新发明* 东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是 *独立的思考能力* 。一旦一个东西被你“想”出来，而不是从别人那里 “学”过来，那么你就知道这个想法是 *如何产生* 的。这比起直接学会这个想法要有用很多，因为你知道这里面 *所有的细节和犯过的错误* 。而最重要的，其实是由此得到的 *直觉* 。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文都会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。
#+END_QUOTE

*** [[http://www.yinwang.org/blog-cn/2012/07/25/semantics][什么是语义学]]

*一个程序的“语义” 通常是由另一个程序（“解释器”）决定的 。 _程序只是一个数据结构_ ，通常表示为语法树(abstract syntax tree)或者指令序列* 。这个数据结构本身其实没有意义，是解释器让它产生了意义，对同一个程序可以有不同的解释。

解释器接受一个“程序”(program)，输出一个“值”(value)。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。

CPU 其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。

*所以“语义学”，基本上就是研究各种解释器。*

解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 lambda calculus 的解释器。lambda calculus 只有三种元素，却可以表达所有程序语言的复杂结构。

#+BEGIN_QUOTE
专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《Programming Languages and Lambda Calculi》。只需要看完前半部分（Part I 和 II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是 lambda calculus）开始讲解 *什么是递归定义，什么是解释，什么是 Church-Rosser，什么是上下文 (evaluation context)* 。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 lambda calculus 和 CEK，SECD 等抽象机 (abstract machine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。
#+END_QUOTE

*** [[http://www.yinwang.org/blog-cn/2012/08/01/interpreter][怎样写一个解释器]]

写一个解释器，通常是设计和实现程序语言的第一步。

实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。

学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。

#+BEGIN_EXPORT html
<essay>
文中王垠实现了一个很简单的语言 - “R2” ，详见原文。
</essay>
#+END_EXPORT

-----
*解释器是什么*

说白了，解释器跟计算器差不多。 *解释器是一个函数* ，你输入一个“表达式”，它就输出一个 “值”。

比如，你输入表达式 ='(+ 1 2)= ，它就输出值，整数 3 。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。

需要注意的是， *表达式是一个数据结构，而不是一个字符串* 。我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如表达式 ='(+ 1 2)= 其实是一个链表（list），它里面的内容是三个符号（symbol）： =+, 1 和 2= ，而不是字符串 ="(+ 1 2)"= 。

从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这是 Lisp 系统比 Unix 系统先进的地方之一。

从计算理论的角度讲，每个程序都是一台机器的“描述”，而 *解释器就是在“模拟”这台机器的运转* ，也就是在进行“计算”。所以从某种意义上讲， *解释器就是计算的本质* 。当然，不同的解释器就会带来不同的计算。

#+BEGIN_EXPORT html
<essay>
解释器，决定了程序的语义。
</essay>
#+END_EXPORT

CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。

-----
*抽象语法树（Abstract Syntax Tree）*

用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构。更具体一点，这叫做“抽象语法树”（Abstract Syntax Tree，简称 AST）。

跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等。

举个简单的例子，表达式 ='(* (+ 1 2) (+ 3 4))= ，就对应如下的语法树结构：

其中， =*= ，两个 =+，1，2，3，4= 都是叶节点，而那三个红色节点，都表示子树结构： ='(+ 1 2)= ， ='(+ 3 4)= ， ='(* (+ 1 2) (+ 3 4))= 。

-----
*树遍历算法*

在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。

*解释器的算法，就是在语法树上的一种遍历操作。*

-----
*模式匹配*

模式匹配的形式一般是这样：

#+BEGIN_EXAMPLE
(match x
  [模式 结果]
  [模式 结果]
   ...   ...
)
#+END_EXAMPLE

它先对 x 求值，然后根据值的结构来进行 *分支* 。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个 match 语句的语义是这样：从上到下依次考虑， *找到第一个可以匹配 x 的值的模式 ，返回它右边的结果* 。左边的模式在匹配之后，可能会 *绑定一些变量* ，这些变量可以在右边的表达式里使用。

#+BEGIN_QUOTE
*模式匹配是一种分支语句* ，它在逻辑上就是 Scheme（Lisp） 的 =cond= 表达式，或者 Java 的嵌套条件语句 =if ... else if ... else ...= 。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数（accessor）或者 foo.x 这样的属性语法（attribute）。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构。
#+END_QUOTE

#+BEGIN_EXAMPLE
`(,e1 ,e2)
'(  1   2)
#+END_EXAMPLE

说白了，模式就是一个可以含有“名字”（像 e1 和 e2）的结构，像 ='(,e1 ,e2)= 。我们拿这个带有名字的结构，去匹配实际数据，像 ='(1 2)= 。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值。

模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员。

-----

