#+DATE: <2021-03-03 Wed 10:19>
#+TITLE: 当然我在扯淡

#+BEGIN_QUOTE
我并不喜欢王垠这个人，甚至有些反感，但他的某些博文我很喜欢，也因此而受益，Hmm...
#+END_QUOTE

*Tip. 非原文摘录，各别语句进行了删减和改动，建议看原文（点击章节标题）。

** Blog Excepts

*** [[http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness][什么是“对用户友好”]]

#+BEGIN_EXPORT html
<img
src="images/yinwang-1.jpg"
width="160"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

#+BEGIN_QUOTE
Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction.

-- Albert Einstein

任何聪明的傻瓜都能把事情做得更大、更复杂、更暴力，而在相反的方向上前进则需要一点天才和很大的勇气。
#+END_QUOTE

“对用户不友好”的背后，其实是程序设计的不合理使得它们 *缺少抽象* ，而不是用户的问题。

#+BEGIN_EXPORT html
<essay>
这点确实，比如，我就总是搞不清楚冰箱中的致冷程度数字、洗衣机面板上的各种设置开关……
</essay>
#+END_EXPORT

如何对用户更加友好呢？ *统一、抽象！*

*** [[http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman][GTF - Great Teacher Friedman]]

程序语言的研究者们往往追逐一些“新概念”，却未能想到很多这些新概念早在几十年前就被 Friedman 想到了。

知识的深度是无止境的。

Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。

在 Friedman 的课上，我利用它们（如 closure 、CPS 等概念）来完成有实际意义的目标，才真正的体会到这些概念的内涵和价值。

#+BEGIN_QUOTE
一个例子就是课程进入到没几个星期的时候，我们开始 *写解释器* 来执行简单的 Scheme 程序。然后我们把这个解释器 *进行 CPS 变换* ，引入全局变量作为 *“寄存器”* (register)，把 CPS 产生的 continuation 转换成 *数据结构（也就是堆栈）* 。最后我们得到的是一个 *抽象机* (abstract machine)，而这在本质上相当于一个真实机器里的中央处理器（CPU）或者虚拟机（比如 JVM）。所以我们其实从无到有，“发明”了 CPU！从这里，我才真正的理解到寄存器，堆栈等的本质，以及我们为什么需要它们。我才真正的明白了，冯诺依曼体系构架为什么要设计成这个样子。后来他让我们去看一篇他的好朋友 Olivier Danvy 的论文，讲述如何从各种不同的解释器经过 CPS 变换得出不同种类的抽象机模型。这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到， *机器并不是计算的本质* 。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料， *我们所要表达的语义，也就是计算的本质，却是不变的。*
#+END_QUOTE

#+BEGIN_QUOTE
当然， *重新发明* 东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是 *独立的思考能力* 。一旦一个东西被你“想”出来，而不是从别人那里 “学”过来，那么你就知道这个想法是 *如何产生* 的。这比起直接学会这个想法要有用很多，因为你知道这里面 *所有的细节和犯过的错误* 。而最重要的，其实是由此得到的 *直觉* 。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文都会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。
#+END_QUOTE

*** [[http://www.yinwang.org/blog-cn/2012/07/25/semantics][什么是语义学]]

*一个程序的“语义” 通常是由另一个程序（“解释器”）决定的 。 _程序只是一个数据结构_ ，通常表示为语法树(abstract syntax tree)或者指令序列* 。这个数据结构本身其实没有意义，是解释器让它产生了意义，对同一个程序可以有不同的解释。

解释器接受一个“程序”(program)，输出一个“值”(value)。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。

CPU 其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。

*所以“语义学”，基本上就是研究各种解释器。*

解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 lambda calculus 的解释器。lambda calculus 只有三种元素，却可以表达所有程序语言的复杂结构。

#+BEGIN_QUOTE
专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《Programming Languages and Lambda Calculi》。只需要看完前半部分（Part I 和 II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是 lambda calculus）开始讲解 *什么是递归定义，什么是解释，什么是 Church-Rosser，什么是上下文 (evaluation context)* 。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 lambda calculus 和 CEK，SECD 等抽象机 (abstract machine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。
#+END_QUOTE

*** TODO [[http://www.yinwang.org/blog-cn/2012/08/01/interpreter][怎样写一个解释器]]

待细读……

*** [[http://www.yinwang.org/blog-cn/2013/03/07/design-patterns][解密设计模式]]

有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）？

总的来说，如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。

可是自从《设计模式》（通常叫做 GoF，“Gang of Four”，“四人帮”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。

#+BEGIN_EXPORT html
<essay>
教条主义不能有！当然，GoF 还是值得读的！
</essay>
#+END_EXPORT

照搬模式东拼西凑，而不能抓住事物的本质，没有“灵感”，其实是设计不出好东西的。

Peter Norvig 在 1998 年就做了一个演讲，指出在“动态语言”里面，GoF 的 20 几个模式，其中绝大部分都“透明”了。也就是说，你根本感觉不到它们的存在。

*** [[http://www.yinwang.org/blog-cn/2013/03/07/linux-windows-mac][谈 Linux, Windows 和 Mac]]

这段时间受到很多人的来信。他们看了我很早以前写的推崇 Linux 的文章，想知道如何“抛弃 Windows，学习 Linux”。天知道他们在哪里找到那么老的文章，真是好事不出门…… 我觉得我有责任消除我以前的文章对人的误导，洗清我这个“Linux 狂热分子”的恶名。

#+BEGIN_EXPORT html
<essay>
Hmm... 我也受这篇文章影响过……
</essay>
#+END_EXPORT

学习操作系统最好的办法是 *学会（真正的）程序设计思想* ，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用程序语言的思想简单的解释。

一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。

#+BEGIN_EXPORT html
<essay>
这里其实是一个悖论，工具实现的其实是心中所想，而如果你要进行精细化的操作，就很难仅用很简单的规则就可以。
</essay>
#+END_EXPORT

有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。

容易的东西不一定是坏的，而困难的东西也不一定是好的。

学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里什么也不会留下。 *学习“原理性”的东西，才是永远不会过时的。*

*** [[http://www.yinwang.org/blog-cn/2013/03/08/on-syntax][谈语法]]

#+BEGIN_EXPORT html
<img
src="http://www.yinwang.org/images/lisp_cycles.png"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

使用和研究过这么多程序语言之后，我觉得几乎不包含多余功能的语言，只有一个： Scheme。

我觉得 Scheme （Lisp） 的基于“S表达式”（S-expression）的语法，是世界上最完美的设计。为什么我喜欢这样一个“全是括号，前缀表达式”的语言呢？这是出于对语言结构本质的考虑。

其实，我觉得语法是完全不应该存在的东西。即使存在，也应该非常的简单。

_语法_ 其实只是对 *语言的本质结构，“抽象语法树”（abstract syntax tree，AST）* 的一种编码。一个良好的编码，应该极度简单，不引起歧义，而且应该容易解码。在程序语言里，这个“解码”的过程叫做“语法分析”（parse）。

为什么我们却又需要语法呢？

因为受到现有工具（操作系统，文本编辑器）的限制，到目前为止，几乎所有语言的程序都是用字符串的形式存放在文件里的。为了 *让字符串能够表示“树”这种结构* ，人们才给程序语言设计了“语法”这种东西。

但是人们喜欢耍小聪明，在有了基本的语法之后，他们开始在这上面大做文章，使得简单的问题变得复杂……

#+BEGIN_EXPORT html
<essay>
语法糖？但有时候真的便捷易用啊……
</essay>
#+END_EXPORT

最老的是 Fortran 的程序，最早的时候都是用打孔机打在卡片上的，所以它其实是几乎没有语法可言的。

#+BEGIN_EXPORT html
<note>
Lisp （Scheme 的前身）是世界上第二老的程序语言。
</note>
#+END_EXPORT

#+BEGIN_EXPORT html
<img
src="http://www.yinwang.org/images/punch-card.gif"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

#+BEGIN_QUOTE
自己想一下，如果要表达一颗“树”，最简单的编码方式是什么？就是用括号把每个节点的“数据”和“子节点”都括起来放在一起。Lisp 的设计者们就是这样想的。他们把这种完全用括号括起来的表达式，叫做“S表达式”（S 代表 “symbolic”）。这貌似很“粗糙”的设计，甚至根本谈不上“设计”。奇怪的是，在用过一段时间之后，他们发现自己已经爱上了这个东西，再也不想设计更加复杂的语法。于是S表达式就沿用至今。
#+END_QUOTE

首先，把所有的结构都用括号括起来，轻松地避免了别的语言里面可能发生的“歧义”。程序员不再需要记忆任何“运算符优先级”。

其次，把“操作符”全都放在表达式的最前面，使得基本算术操作和函数调用，在语法上发生 *完美的统一* ，而且使得程序员可以使用几乎任何符号作为函数名。

#+BEGIN_EXPORT html
<note>
拓展阅读“前缀表达式”和“中缀表达式”相关知识。
</note>
#+END_EXPORT

#+BEGIN_QUOTE
在其他的语言里，函数调用看起来像这个样子： =f(1)= ，而算术操作看起来是这样： =1+2= 。在 Lisp 里面，函数调用看起来是这样 =(f 1)= ，而算术操作看起来也是这样 =(+ 1 2)= 。你发现有什么共同点吗？那就是 =f= 和 =+= 在位置上的对应。实际上，加法在本质也是一个函数。这样做的好处，不但是突出了加法的这一本质，而且它让人可以用跟定义函数一模一样的方式，来定义“运算符”！这比起 C++ 的“运算符重载”强大很多，却又极其简单。
#+END_QUOTE

Lisp 的很多其它的设计，比如“垃圾回收”，后来被很多现代语言（比如 Java）所借鉴。可是人们遗漏了一个很重要的东西：Lisp 的语法，其实才是世界上最好的语法。

#+BEGIN_EXPORT html
<essay>
我也感觉 S-expression 很好用！
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/15/language-design-mistake1][程序语言的常见设计错误 - 片面追求短小]]

我的程序的“短小”是建立在 *语义明确，概念清晰* 的基础上的。在此基础上，我力求去掉冗余的，绕弯子的，混淆的代码，让程序更加直接，更加高效的表达我心中设想的“模型”。这是一种在概念级别的优化，而程序的短小精悍只是它的一种“表象”。

我的这种短小往往是在 *语义和逻辑层面* 的，而不是在语法上死抠几行代码。我绝不会为了程序显得短小而让它变得难以理解或者容易出错。

#+BEGIN_EXPORT html
<essay>
文中举了两个小例子，这里只做简要概括。
</essay>
#+END_EXPORT

-----
*1.自增减操作*

从理论上讲， *自增减操作本身就是错误的设计* 。因为它们把对变量的“读”和“写”两种根本不同的操作，毫无原则的合并在一起。这种对读写操作的混淆不清，带来了非常难以发现的错误。相反，一种等价的，“笨”一点的写法， =i = i + 1= ，不但更易理解，而且在逻辑上更加清晰。

有些人很在乎 =i++= 与 =++i= 的区别，去追究 =i++= 与 =++i= 谁的效率更高。这些其实都是徒劳的。比如，i++ 与 ++i 的效率差别，其实来自于早期 C 编译器的愚蠢。

#+BEGIN_EXPORT html
<essay>
以下是正确讲解 i++ 的办法！！！它曾是多少人的痛……
</essay>
#+END_EXPORT

因为 *=i++= 需要在增加之后返回 =i= 原来的值* ，所以它其实被编译为：

#+BEGIN_EXAMPLE
(tmp = i, i = i + 1, tmp)
#+END_EXAMPLE

但是在 =for (int i = 0; i < max; i++)= 中，其实你并不需要在 =i++= 之后得到它自增前的值。所以有人说，在这里应该用 =++i= 而不是 =i++= ，否则你就会浪费一次对中间变量 =tmp= 的赋值。

而其实呢，一个良好设计的编译器应该在两种情况下都生成相同的代码。

#+BEGIN_EXAMPLE
# 在 i++ 的情况，代码其实先被转化为
for (int i = 0; i < max; (tmp = i, i = i + 1, tmp))

# ↓↓↓

# 由于 tmp 这个临时变量从来没被用过，
# 所以它会被编译器的“dead code elimination”消去，
# 编译器最后实际上得到了
for (int i = 0; i < max; i = i + 1)
#+END_EXAMPLE

所以，“精通”这些细微的问题，并不能让你成为一个好的程序员。很多人所认为的高明的技巧，经常都是因为早期系统设计的缺陷所致。一旦这些系统被改进，这些技巧就没什么用处了。

真正正确的做法其实是：完全不使用自增减操作，因为它们本来就是错误的设计。

-----
*2.赋值语句返回值*

在几乎所有像 C，C++，Java 的语言里，赋值语句都可以被作为值。

=y = 0= 不应该具有一个值。它的作用应该是“赋值”这种“动作”，而不应该具有任何“值”。即使牵强一点硬说它有值，它的值也应该是 =void= 。这样一来 =x = y = 0= 和 =if (y = 0)= 就会因为“类型不匹配”而被编译器拒绝接受，从而避免了可能出现的错误。

#+BEGIN_EXPORT html
<essay>
if (y == 0) 写成 if (y = 0) ，Hmm……
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/19/eliminate-problems][“解决问题”与“消灭问题”]]

如果你仔细观察就会发现，很多“难题”，其实是“人造”出来的，而不是“必然”的。它们的存在，往往是由于一些早期的“设计错误”。

如果我们转换一下思路，或者改变一下“设计”，很多问题就可以不解自消。这就是我所谓的“消灭问题”的能力。

所以，在解决问题之前，我们应该先问自己三个问题：

1. 这问题是否真的“存在”？
2. 如果解决了这个问题，会给我和他人在合理的时间之内带来什么实际的好处？
3. 这问题是否可以在简单的改变某些“设计”或者“思路”之后，不复存在？

#+BEGIN_EXPORT html
<essay>
本质上是认真思考一下问题产生的原因！
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive][Lisp 已死，Lisp 万岁！]]

*1.Lisp 的优点：*

Lisp 的语法是世界上最精炼，最美观，也是语法分析起来最高效的语法。这是 Lisp 独一无二的，其他语言都没有的优点。有些人喜欢设计看起来很炫的语法，其实都是自找麻烦。为什么这么说呢，请参考这篇[[http://www.yinwang.org/blog-cn/2013/03/08/on-syntax][《谈语法》]] 。

Lisp 是第一个可以 *在程序的任何位置定义函数* ，并且可以 *把函数作为值传递* 的语言。这样的设计使得它的表达能力非常强大。这种理念被 Python，JavaScript，Ruby 等语言所借鉴。

Lisp 有世界上最强大的宏系统（macro system）。这种宏系统的表达力几乎达到了理论所允许的极限。如果你只见过 C 语言的“宏”，那我可以告诉你它是完全没法跟 Lisp 的宏系统相提并论的。

Lisp 是世界上第一个使用垃圾回收（ garbage collection）的语言。这种超前的理念，后来被 Java，C# 等语言借鉴。

#+BEGIN_QUOTE
想不到吧，现代语言的很多优点，其实都是来自于 Lisp — 世界上第二古老的程序语言。所以有人才会说，每一种现代语言都在朝着 Lisp 的方向“进化”。

如果你相信了这话，也许就会疑惑，为什么 Lisp 今天没有成为主流？为什么 Lisp Machine 会被 Unix 打败？其实除了商业原因之外，还有技术上的问题。
#+END_QUOTE

-----
*2.Dynamic Scoping*

早期的 Lisp 其实普遍存在一个非常严重的问题：它使用 *dynamic scoping* 。

所谓 dynamic scoping 就是说，如果你的函数定义里面有 *“自由变量”* ，那么这个自由变量的值，会随着函数的“调用位置”的不同而发生变化。

#+BEGIN_SRC lisp -n
(setq f
      (let ((x 1))
        (lambda (y) (* x y))))
#+END_SRC

这里的 =x= 对于函数 =(lambda (y) (* x y))= 来说就是个“自由变量”（free variable），因为它不是它的参数。

……

#+BEGIN_QUOTE
Tips: 详细论证过程就参考原文……
#+END_QUOTE

话说回来，为什么早期的 Lisp 会使用 dynamic scoping 呢？

原来，Emacs Lisp 直接把函数定义处的 S 表达式 ='(lambda (y) (* x y))= 作为了函数的“值”！

如果你在 emacs 里面显示 =f= 的值，它会打印出：

#+BEGIN_EXAMPLE
'(lambda (y) (* x y))
#+END_EXAMPLE

这说明 =f= 的值其实是一个 S 表达式，而不是像 Scheme 一样的“闭包”（closure）。

简单倒是简单，麻烦事接着就来了。调用 f 的时候，比如 =(funcall f 2)= ，y 的值当然来自参数 2，可是 x 的值是多少呢？答案是：不知道！不知道怎么办？到“外层环境”去找呗，看到哪个就用哪个，看不到就报错。所以你就看到了之前出现的现象，函数的行为随着一个完全无关的变量而变化。如果你单独调用 =(funcall f 2)= 就会因为找不到 x 的值而出错。

那么正确的实现函数的做法是什么呢？是制造“闭包”(closure)！这也就是 Scheme，Common Lisp 以及 Python，C# 的做法。

在函数定义被解释或者编译的时候，当时的自由变量（比如 x）的值，会跟函数的代码绑在一起，被放进一种叫做“闭包”的结构里。比如上面的函数，就可以表示成这个样子： =(Closure ‘(lambda (y) (* x y)) ‘((x . 1)))= 。

在这里我用 =(Closure …)= 表示一个“结构”（就像 C 语言的 struct）。它的第一个部分，是这个函数的定义。第二个部分是 =‘((x . 1))= ，它是一个 *“环境”* ，其实就是一个从变量到值的映射（map）。利用这个映射，我们记住函数定义处的那个 x 的值，而不是在调用的时候才去瞎找。

-----
*3.Lexical Scoping*

与 dynamic scoping 相对的就是“lexical scoping”。我刚才告诉你的闭包，就是 lexical scoping 的实现方法。

你也许发现了，Lisp 其实不是一种语言，而是很多种语言。这些被人叫做“Lisp 家族”的语言，其实共同点只是它们的“语法”：它们都是基于 S 表达式。如果你因此对它们同样赞美的话，那么你赞美的其实只是 S 表达式，而不是这些语言本身。

因为 *一个语言的本质应该是由它的语义决定的，而跟语法没有很大关系。* 你甚至可以给同一种语言设计多种不同的语法，而不改变这语言的本质。

*** [[http://www.yinwang.org/blog-cn/2013/03/28/chez-scheme][Chez Scheme 的传说]]

在我看来，早期 Lisp 编译器出现的主要问题，其实在于对编译的本质的理解，以及编译器与解释器的根本区别。

*解释器之所以大部分时候比编译器慢，是因为解释器“问太多的问题”。* 每当看到一个构造，解释器就会问：“这是一个整数吗？”“这是一个字符串吗？”“这是一个函数吗？”…… 然后根据问题的结果进行不同的处理。这些问题，在编译器的理论里面叫做 *“解释开销”* （interpretive overhead）。

*编译的本质，其实就是在程序运行之前进行“静态分析”，试图一劳永逸的回答这些问题。*

早期的 Lisp 编译器，以及现在的很多 Scheme 编译器出现的问题其实在于，它们并没有干净的消除这些问题，甚至根本没有消除这些问题。

编译的过程，就是将输入程序经过一系列的变换之后，转化为机器代码。

*** [[http://www.yinwang.org/blog-cn/2013/03/29/scripting-language][什么是“脚本语言”]]

其实“脚本语言”与“非脚本语言”并没有语义上，或者执行方式上的区别。它们的区别只在于它们设计的初衷：脚本语言的设计，往往是作为一种临时的“补丁”。相反，“非脚本”的通用程序语言，往往由经过严格训练的专家甚至一个小组的专家设计，它们从一开头就考虑到了“通用性”，以及在大型工程中的可靠性和可扩展性。

“脚本”这个概念是如何产生的？

使用 Unix 系统的人都会敲入一些命令，而命令貌似都是“一次性”或者“可抛弃”的。然而不久，人们就发现这些命令其实并不是那么的“一次性”，自己其实一直在重复的敲入类似的命令，所以有人就发明了“脚本”这东西。它的 *设计初衷是“批量式”的执行命令* ，你在一个文件里把命令都写进去，然后执行这个文件。可是不久人们就发现，这些命令行其实可以用更加聪明的方法构造，比如定义一些变量，或者根据系统类型的不同执行不同的命令。于是，人们为这脚本语言加入了变量，条件语句，数组，等等构造。“脚本语言”就这样产生了。

*** TODO [[http://www.yinwang.org/blog-cn/2013/04/11/scheme-setup][Scheme 编程环境的设置]]

#+BEGIN_EXPORT html
<essay>
学习 Sheme 的时候可以参考下……
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/04/17/languages][关于语言的思考]]

怎么说呢，我觉得每个程序员的生命中都至少应该有几个月在静心学习 Haskell。学会 Haskell 就像吃几天素食一样。每天吃素食显然会缺乏全面的营养，但是每天都吃荤的话，你恐怕就永远意识不到身体里的毒素有多严重。

我今天想说其实就是，没有任何一种语言值得你用毕生的精力去“精通”它。“精通”其实代表着“脑残”——你成为了一个高效的机器，而不是一个有自己头脑的人。你必须对每种语言都带有一定的怀疑态度，而不是完全的拥抱它。 *每个人都应该学习多种语言* ，这样才不至于让自己的思想受到单一语言的约束，而没法接受新的，更加先进的思想。这就像每个人都应该学会至少一门外语一样，否则你就深陷于自己民族的思维方式。有时候这种民族传统的思想会让你深陷无须有的痛苦却无法自拔。

*** [[http://www.yinwang.org/blog-cn/2013/04/26/reason-and-proof][原因与证明]]

一个东西具有如此的性质，并不是因为你证明了它。这性质是它天生就有的，不管你是否能证明它。

了大部分的教育过分的重视了“证明”，却忽略了比证明更重要的东西——“原因”。

#+BEGIN_QUOTE
*原因往往比证明来得更加简单，更加深刻，但却更难发现。* 对于一个事实往往有多种多样的证明，然而导致这个事实的原因却往往只有一个。如果你只知道证明却不知道原因，那你往往就被囚禁于别人制造的理论里面，无法自拔。你能证明一个事物具有某种特性，然而你却没有能力改变它。你无法对它加入新的，好的特性，也无法去掉一个不好的特性。你也无法发明新的理论。有能力发明新的事物和理论的人，他们往往不仅知道“证明”，而且知道“原因”。
#+END_QUOTE

古人说的“知其然”与“知其所以然”的区别，也就是同样的道理吧。

*** [[http://www.yinwang.org/blog-cn/2013/07/13/church-turing][丘奇和图灵]]

丘奇代表了“逻辑”和“语言”，而图灵代表着“物理”和“机器”。完全投靠丘奇，或者完全投靠图灵，貌似都是错误的做法。

据我的经验，丘奇的理论让很多事情变得简单，而图灵的机器却过度的复杂。丘奇所发明的 =lambda calculus= 以及后续的工作，是几乎一切程序语言的理论基础。

图灵机永远的停留在了理论的领域，绝大多数被用在“计算理论”（Theory of Computation）中。

计算理论其实包括两个主要概念： *“可计算性理论”（computability）* 和 *“复杂度理论”(complexity）* 。

这两个概念在通常的计算理论书籍（比如 Sipser 的经典教材）里，都是用图灵机来叙述的。其实几乎所有计算理论的原理，都可以用 =lambda calculus= ，或者程序语言和解释器的原理来描述。

所谓“通用图灵机”（Universal Turing Machine），其实就是一个 *可以解释自己的解释器* ，叫做“元解释器”（meta-circular interpreter）。

然而我的“元解释器”却是基于 =lambda calculus= 的，所以我后来发现了一种方法，可以完全的用 =lambda calculus= 来解释计算理论里面几乎所有的定理。

#+BEGIN_QUOTE
在我的头脑里面并存着丘奇和图灵的影子。我觉得丘奇的 =lambda calculus= 是比图灵机简单而强大的描述工具，然而我却又感染到了图灵对于“物理”和“机器”的执着。我觉得逻辑学家们对 =lambda calculus= 的解释过于复杂，而通过把它理解为物理的“电路元件”，让我对 =lambda calculus= 做出了更加简单的解释，把它与“现实世界”联系在了一起。
#+END_QUOTE

所以到最后，丘奇和图灵这两种看似矛盾的思想，在我的脑海里得到了和谐的统一。这些精髓的思想帮助我解决了许多的问题。

*** [[http://www.yinwang.org/blog-cn/2014/01/04/authority][我和权威的故事]]

*Donald Knuth*

#+BEGIN_EXPORT html
<img
src="images/yinwang-2.jpg"
width="400"
height=""
style=""
title=""
/>
#+END_EXPORT

有一句话说得好：“跟真正的大师学习，而不是跟他们的徒弟。”如果你真的要学一个算法，就应该直接去读那算法的发明者的论文，而不是转述过来的“二手知识”。二手的知识往往把发明者原来的动机和思路都给去掉了，只留下苍白无味，没有什么启发意义的“最后结果”。

#+BEGIN_QUOTE
我跟 Knuth 的最后一次“联系”是在我就要离开清华的时候。我从 email 告诉他我觉得中国的研究环境太浮躁了，不是做学问的好地方，想求点建议。结果他回纸信说：“可我为什么看到中国学者做出那么多杰出的研究？计算机科学不是每个人都可以做的。如果你试了这么久还不行，那说明你注定不是干这行的料。”还好，我从来没有相信他的这段话，我下定了决心要证明这是错的。多年的努力还真没有白费，今天我可以放心的说，Knuth 你错了，因为我已经在你引以为豪的多个方面超过了你。
#+END_QUOTE

#+BEGIN_EXPORT html
<essay>
Hmm……
</essay>
#+END_EXPORT

*Unix*

所谓的“Unix 哲学”，也就是进程间通信主要依靠无结构字符串，造成了一大批过度复杂，毛病众多的工具和语言的产生： AWK，sed，Perl，……

Lisp 程序员早就明白这个道理，所以他们尽一切可能避免使用字符串。他们设计了 S 表达式，用于结构化的传输数据。实际上 S 表达式不是“设计”出来的，它是每个人都应该首先想到的，最简单的可以 *表示树结构* 的编码方法。Lisp 的设计原则里面有一条就是：Do not encode。它的意思是，尽量不要把有用的数据编码放进字符串。

*Go 语言*

……

*Cornell*

……

*图灵奖*

说到这里应该有人会问这个问题，我是不是也属于那种没找到导师走投无路的人。答案是，对的，我确实没有在 Cornell 找到可以做我导师的人。

……

*再见了，权威们*

几经颠簸的求学生涯，让我获得了异常强大的力量。我的力量不仅来自于老师们的教诲，而且在于我自己不懈的追求，因为机会只亲睐有准备的头脑。

#+BEGIN_EXPORT html
<essay>
王垠指出了现存的许多问题和弊端，也提出了许多改进和设想，然而只到现在也没有一件可用的…… 我倒觉得他应该听 Knuth 的，如他现在这样，开班教学也不错。
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2014/01/25/pl-and][程序语言与……]]

程序语言的设计类似于其它很多东西的设计，有些微妙的地方只有用过更好的设计的人才能明白。

……

*程序语言与减肥*

我的方法就是一句话：让每天吃进去的热量比消耗的少一些，但是不至于难受，另外适当运动来增加热量的消耗。很显然嘛，根据热力学定律，每天消耗的能量比摄入的多，多出来的部分只能通过分解你身上的物质（脂肪）来产生。

*** [[http://www.yinwang.org/blog-cn/2014/02/09/programmer-mental][程序员的心理疾病]]

*1.无自知之明*

由于程序员的工作最近几年比较容易找，工资还不错，所以很多程序员往往只看到自己的肚脐眼，看不到自己在整个社会里的位置其实并不是那么的关键和重要。很多程序员除了自己会的那点东西，几乎对其它领域和事情完全不感兴趣，看不起其他人……

#+BEGIN_EXPORT html
<essay>
这一点确实需要警醒！！！
</essay>
#+END_EXPORT

*2.垃圾当宝贝*

按照 Dijkstra 的说法，“软件工程”是穷途末路的领域，因为它的目标是： 如果 *我不会写* 程序的话，怎么样才 *能写出* 程序？

为了达到这个愚蠢的目的，很多人开始兜售各种像减肥药一样的东西。面向对象方法，软件“重用”，设计模式，关系式数据库，NoSQL，大数据…… 没完没了。

#+BEGIN_EXPORT html
<essay>
不赞同！
</essay>
#+END_EXPORT

*3.宗教斗争*

为什么有人说在软件行业里需要不停地“学习”，因为不断地有人为了制造新的理念而制造新的理念。

#+BEGIN_EXPORT html
<img
src="images/yinwang-3.jpg"
width="600"
height=""
style=""
title=""
/>
#+END_EXPORT

……

*4. 以语言取人*

很多程序员都以自己会用最近流行的一些新语言为豪，以为有了它们自己就成了更好的程序员。他们看不到，用新的语言并不能让他们成为更好的程序员。其实最厉害的程序员无论用什么语言都能写出很好的代码。在他们的头脑里其实只有一种很简单的语言，他们首先用这种语言把 *问题建模* 出来，然后根据实际需要“翻译”成最后的代码。这种在头脑里的建模过程的价值，是很难用他最后用语言的优劣来衡量的。

……

*** [[http://www.yinwang.org/blog-cn/2014/02/18/dijkstra-interview][一个对 Dijkstra 的采访视频]]

（可以访问 [[http://www.youtube.com/watch?v=RCCigccBzIU][YouTube]] 或者从源地址下载 [[http://www.cs.utexas.edu/users/EWD/video-audio/NoorderlichtVideo.html][MPEG1]]，300M）

现在看来，任何一个语言里面没有递归函数都是不可思议的事情，然而在1950-60年代的时候，居然很少有人知道它有什么用！所以你就发现，所谓的“主流”和“大多数人”一直都是比较愚蠢的。现在，同样的故事发生在 lambda 身上。多年以后，没有 lambda 的语言将是不可接受的。

*在这里只摘录他提到的几个要点：*

软件测试可以确定软件里有 bug，但却不可能用来确定它们没有 bug。

程序的优雅性不是可以或缺的奢侈品，而是决定成功还是失败的一个要素。优雅并不是一个美学的问题，也不是一个时尚品味的问题，优雅能够被翻译成可行的技术。牛津字典对 elegant 的解释是： pleasingly ingenious and simple。如果你的程序真的优雅，那么它就会容易管理。第一是因为它比其它的方案都要短，第二是因为它的组件都可以被换成另外的方案而不会影响其它的部分。很奇怪的是，最优雅的程序往往也是最高效的。

为什么这么少的人追求优雅？这就是现实。如果说优雅也有缺点的话，那就是 *你需要艰巨的工作才能得到它，需要良好的教育才能欣赏它* 。

当没有计算机的时候，编程不是问题。当有了比较弱的计算机时，编程成了中等程度的问题。现在我们有了巨大的计算机，编程就成了巨大的问题。

我最开头编程的日子跟现在很不一样，因为我是给一个还没有造出来的计算机写程序。造那台机器的人还没有完工，我在同样的时间给它做程序，所以没有办法测试我的代码。于是我发现自己做的东西必须要能放进自己的脑子里。

我的母亲是一个优秀的数学家。有一次我问她几何难不难，她说一点也不难，只要你用“心”来理解所有的公式。如果你需要超过 5 行公式，那么你就走错路了。

*** TODO [[http://www.yinwang.org/blog-cn/2014/03/24/academic-corruption][学术腐败是历史的必然]]
……

*** TODO [[http://www.yinwang.org/blog-cn/2014/04/24/relational][关系式模型的实质]]

……

*** [[http://www.yinwang.org/blog-cn/2014/09/15/innovation][谈创新]]

有人告诉我，我所说的很多事情只是在已有的事物上面挑出毛病来，那不能引起真正的“创新”。

什么是创新？创新真的那么重要吗，它的意义何在？

世界上并不缺少创新，而是创新过剩了！大量的所谓“创新”，让人们的生活变得纷繁复杂，导致他们需要记住更多事物的用法，而无法专注于利用已有的设施，最大限度的享受生活的乐趣。

最缺乏创造力的人，往往是最爱标榜创新的。

创新往往也是与良好的设计理念背道而驰的。一个好的设计，总是力求减少“新”的感觉，而着重于让整个设计浑然一体，天衣无缝，用起来顺手。最好的设计就是让设计的目标消失掉，或者感觉不到它的存在。

#+BEGIN_EXPORT html
<essay>
这里王垠有些偷换概念了……
</essay>
#+END_EXPORT

……

*美国和中国*

#+BEGIN_QUOTE
在这里提到美国的优秀设计，并不是说我更喜欢美国。每次提到这些，总有朋友感觉不平，仿佛觉得我是“美帝的走狗”一样。 *我其实对任何国家都没有特别的感情和归属感，我的感情只针对个人，而不是国家。实际上，我认为国家这种东西是不必要存在的。* 美国人对我显然没有很多中国人对我好，然而 *技术和设计是没有国界的* ，好的东西不学就等于永远落后。很多中国人喜欢用所谓的“民族自豪感”来代替理性的思考，看不到自己的问题。中国为什么到现在还属于第三世界国家，恐怕就有这里面的原因。没有用心，就不能提高。中国的经济发展了，国家的总资产可以说已经很多了，然而有很多东西不是钱就可以买来的，它需要用心设计。看，我在美国受了这么多的苦和委屈才学会了这些，如果你们不理解消化，那多可惜啊。
#+END_QUOTE

#+BEGIN_EXPORT html
<essay>
你的朋友说的是对的！！！都 2021 了，还持有这种思想（“技术和设计是没有国界的”）的人，在我看来不是坏透了，就是个傻B ……
</essay>
#+END_EXPORT

一味的试图创新而不仔细思考，是人们的生活由于各种“新事物”而变得复杂的重要原因。

只有你能从已有的东西里面看到实质的问题，你才有可能达到天衣无缝的设计。设计不需要全新的，它必须最大限度的让人可以方便的生活，而不需要记忆很多不必要的指令。否则如果你不吸取历史的教训，做出所谓“全新”的设计，那么你很有可能不是解决了问题，而是制造了问题。我觉得有一句话说得好，忘记历史就是毁灭未来。

*** [[http://www.yinwang.org/blog-cn/2015/02/24/human-errors][所谓“人为错误”]]

在我看来，整个软件行业基本就是建立在一堆堆的设计失误之上。做程序员如此困难和辛苦，大部分原因就是因为软件系统里面积累了大量前人的设计失误，所以我们需要做大量的工作来弥补或者绕过。

然而一般程序员都没有意识到这里面的设计错误，知道了也不敢指出来，他们反而喜欢显示自己死记硬背得住这些稀奇古怪的规则。这就导致了软件行业的“皇帝的新装现象”——没有人敢说工具的设计有毛病，因为如果你说出来，别人就会认为你在抱怨，那你不是经验不足，就是能力不行。

我体会很深的一个例子就是Git版本控制工具。有人很把这种东西当回事，引以为豪记得住如何用一些稀奇古怪的Git命令（比如git rebase, git submodule之类）。好像自己知道了这些就真的是某种专家一样，每当遇到不会用这些命令的人，都在心底默默地鄙视他们。 *作为一个比 Git 的作者还要高明的程序员，我却发现自己永远无法记住那些命令* 。在我看来，这些命令晦涩难懂，很有可能是因为没设计好造成的。因为如果一个东西设计好了，以我的能力是不可能不理解的。可是Linus Torvalds的名气之大，威望之高，有谁敢说：“我就是不会用你设计的破玩意儿！你把我怎么着？

#+BEGIN_EXPORT html
<essay>
Hmm…… 如果你高明到让自己并不高明，是不是说明你并不如自己想象的那么高明……
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2015/03/03/how-to-respect-a-programmer][怎样尊重一个程序员]]

*1.认识和承认技术领域的历史遗留糟粕*

很多不尊重人现象的起源，都是因为某些人偏执的相信某种技术就是世界上最好的，每个人都必须知道这些东西，否则他就不是一个合格的程序员。

如果你对计算机科学理解到一定程度，就会发现我们其实仍然生活在计算机的石器时代。特别是软件系统，建立在一堆历史遗留的糟糕设计之上。

各种蹩脚脑残的操作系统（比如 Unix，Linux），程序语言（比如 C++，JavaScript，PHP，Go)，数据库，编辑器，版本控制工具，…… 时常困扰着我们，这就是为什么你需要那么多的所谓“经验”和“知识”。

*2.分清精髓知识和表面知识，不要太拿经验当回事*

在任何领域，都只有少数知识是精髓的，另外大部分都是表面的，肤浅的，是从精髓知识衍生出来的。

精髓知识和表面知识都是有用的，然而它们的分量和重要性却是不一样的。所以必须区分精髓知识和表面知识，不能混为一谈，对待它们的态度应该是不一样的。由于表面知识基本是死的，而且很容易从精髓知识推导衍生出来。我们不应该因为自己知道很多表面知识，就自以为比掌握了精髓知识的人还要强。不应该因为别人不知道某些表面知识，就以为自己高人一等。

……

*** [[http://www.yinwang.org/blog-cn/2015/04/03/paradigms][编程的宗派]]

总是有人喜欢争论这类问题，到底是“函数式编程”（FP）好，还是“面向对象编程”（OOP）好……

*1.面向对象编程（Object-Oriented Programming）*

如果你看透了表面现象就会发现，其实“面向对象编程”本身没有引入很多新东西。

所谓“面向对象语言”，就是经典的“过程式语言”（比如 Pascal），加上一点抽象能力。所谓“类”和“对象”，基本是过程式语言里面的记录（record，或者叫结构，structure），它 *本质其实是一个从名字到数据的“映射表”（map）* 。

你可以用名字从这个表里面提取相应的数据。

*所谓“对象思想”（区别于“面向对象”），实际上就是对这种数据访问方式的进一步抽象。*

“对象思想”的价值，它让你可以通过“间接”（indirection，或者叫做 *“抽象”* ）来 改变 =point.x= 和 =point.y= 的语义，从而让使用者的代码 *完全不用修改* 。虽然你的实际数据结构里面 *可能没有* x 和 y 这两个成员，但由于 =.x= 和 =.y= *可以被重新定义* ，所以你可以通过改变 .x 和 .y 的定义来“模拟”它们。在你使用 =point.x= 和 =point.y= 的时候，系统内部其实在运行两片代码（所谓 getter），它们的作用是从 r 和 angle 计算出 x 和 y 的值。这样你的代码就感觉 x 和 y 是实际存在的成员一样，而 *其实它们是被临时算出来的* 。

对象思想的价值也就到此为止了。你见过的所谓“面向对象思想”，几乎无一例外可以从这个想法推广出来。

“对象思想”作为数据访问的方式，是有一定好处的。然而“面向对象”（多了“面向”两个字），就是把这种本来良好的思想东拉西扯，牵强附会，发挥过了头。

很多面向对象语言号称“所有东西都是对象”（Everything is an Object）， *把所有函数都放进所谓对象里面，叫做“方法”（method），把普通的函数叫做“静态方法”（static method）* 。

实际上呢，就像我之前的例子，只有极少需要抽象的时候，你需要使用内嵌于对象之内，跟数据紧密结合的“方法”。其他的时候，你其实只是想表达数据之间的变换操作，这些完全可以用普通的函数表达，而且这样做更加简单和直接。

*这种把所有函数放进方法的做法是本末倒置的，因为函数并不属于对象。* 绝大部分函数是独立于对象的，它们不能被叫做“方法”。强制把所有函数放进它们本来不属于的对象里面，把它们全都作为“方法”，导致了面向对象代码逻辑过度复杂。

面向对象语言不仅有自身的根本性错误，而且由于面向对象语言的设计者们常常是半路出家，没有受到过严格的语言理论和设计训练却又自命不凡，所以经常搞出另外一些奇葩的东西。比如在 JavaScript 里面，每个函数同时又可以作为构造函数（constructor），所以每个函数里面都隐含了一个 this 变量，你嵌套多层对象和函数的时候就发现没法访问外层的 this，非得“bind”一下。Python 的变量定义和赋值不分，所以你需要访问全局变量的时候得用 global 关键字，后来又发现如果要访问“中间层”的变量，没有办法了，所以又加了个 nonlocal 关键字……

有些人问我为什么有些语言设计成那个样子，我只能说，很多语言设计者其实根本不知道自己在干什么。

-----
*2.函数式编程（Functional Programming）*

有人盲目的相信函数式编程能够奇迹般的解决并发计算的难题，而看不到实质存在的，独立于语言的问题。

函数式编程当然提供了它自己的价值。函数式编程相对于面向对象最大的价值，莫过于对于函数的正确理解。

在函数式语言里面，函数是“一类公民”（first-class）。它们可以像 1, 2, “hello”，true，对象…… 之类的“值”一样，在任意位置诞生，通过变量，参数和数据结构传递到其它地方，可以在任何位置被调用。这些是很多过程式语言和面向对象语言做不到的事情。

#+BEGIN_QUOTE
很多所谓“面向对象设计模式”（design pattern），都是因为面向对象语言没有 first-class function，所以导致了 *每个函数必须被包在一个对象里面才能传递到其它地方* 。
#+END_QUOTE

函数式编程的另一个贡献，是它们的类型系统。

函数式语言对于类型的思维，往往非常的严密。函数式语言的类型系统，往往比面向对象语言来得严密和简单很多，它们可以帮助你对程序进行严密的逻辑推理。然而类型系统一是把双刃剑，如果你对它看得太重，它反而会带来不必要的复杂性和过度工程。

-----
*3.符号必须简单的对世界建模*

在我的心目中其实只有一个概念，它叫做“编程”（programming），它不带有任何附加的限定词（比如“函数式”或者“面向对象”）。我研究的领域称叫做“Programming Languages”，它研究的内容不局限于某一个语言，也不局限于某一类语言，而是所有的语言。在我的眼里， *所有的语言都不过是各个特性的组合* 。所以最近出现的所谓“新语言”，其实不大可能再有什么真正意义上的创新。我不喜欢说“发明一个程序语言”，不喜欢使用“发明”这个词，因为不管你怎么设计一个语言，所有的特性几乎都早已存在于现有的语言里面了。我更喜欢使用“设计”这个词，因为虽然一个语言没有任何新的特性，它却有可能在细节上更加优雅。

*编程最重要的事情，其实是让写出来的符号，能够简单地对实际或者想象出来的“世界”进行建模。*

一个程序员最重要的能力，是直觉地看见符号和现实物体之间的对应关系。不管看起来多么酷的语言或者范式，如果必须绕着弯子才能表达程序员心目中的模型，那么它就不是一个很好的语言或者范式。

关于建模的另外一个问题是，你心里想的模型，并不一定是最好的，也不一定非得设计成那个样子。

有些人心里没有一个清晰简单的模型，觉得某些语言“好用”，就因为它们能够对他那种扭曲纷繁的模型进行建模。所以你就跟这种人说不清楚，为什么这个语言不好，因为显然这个语言对他是有用的！

*** TODO [[http://www.yinwang.org/blog-cn/2015/06/07/software-engineering][所谓软件工程]]

#+BEGIN_EXPORT html
<essay>
这是一个比较有趣的话题，后续可以了解一下。
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2015/06/14/dry-principle][DRY原则的误区]]

简言之，DRY（Don't Repeat Yourself）原则鼓励对代码进行抽象，但是鼓励得过了头

*1.抽象与可读性的矛盾*

代码的“抽象”和它的“可读性”（直观性），其实是一对矛盾的关系。适度的抽象和避免重复是有好处的，它甚至可以提高代码的可读性，然而如果你尽“一切可能”从代码里提取模板，甚至把一些微不足道的“共同点”也提出来进行“共享”，它就开始有害了。

这是因为， *模板并不直接显示在“调用”它们的位置* 。提取出模板，往往会使得阅读代码时不能一目了然。如果由此带来的直观性损失超过了模板所带来的好处时，你就应该考虑避免抽象了。

*2.抽象的时机问题*

抽象的思想，关键在于“发现两个东西是一样的”。然而很多时候，你开头觉得两个东西是一回事，结果最后发现，它们其实只是肤浅的相似，而本质完全不同。 *防止过早抽象* 的方法其实很简单，它的名字叫做“等待”。

*** [[http://www.yinwang.org/blog-cn/2015/07/02/program-correctness][谈程序的正确性]]

100% 可靠的代码，这是多么完美的理想！然而它并不存在！！！

*1.衡量程序最重要的标准*

许多人其实不明白一个重要的道理： *你得先写出程序，才能开始谈它的正确性* 。看一个程序好不好，最重要的标准，是看它能否有效地解决问题，而不是它是否正确。如果你的程序没有解决问题，或者解决了错误的问题，或者虽然解决问题但却非常难用，那么这程序再怎么正确，再怎么可靠，都不是好的程序。

正确不等于简单，不等于优雅，不等于高效。一个不简单，不优雅，效率低的程序，就算你费尽周折证明了它的正确，它仍然不会很好的工作。

*2.如何提高程序的正确性*

话说回来，虽然程序的正确性相对于解决问题，处于相对次要的地位，然而它确实是不可忽视的。

如果你深入研究过程序的逻辑推导就会知道，测试和形式化证明的能力都是非常有限的。

那么提高程序正确性最有效的方法是什么呢？在我看来，最有效的方法莫过于对代码反复琢磨推敲，让它变得简单，直观，直到你一眼就可以看得出它不可能有问题。

#+BEGIN_EXPORT html
<essay>
具体如何做呢？
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2015/09/19/parser][对 Parser 的误解]]

*1. 什么是 Parser*

#+BEGIN_QUOTE
*所谓 parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。*
#+END_QUOTE

最常见的 parser，是把程序文本转换成编译器内部的一种叫做“抽象语法树”（AST）的数据结构。也有简单一些的 parser，用于处理 CSV，JSON，XML 之类的格式。

之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。实际上， *代码的本质根本就不是字符串* ，它本来就是一个具有复杂拓扑的数据结构，就像电路一样。“1+2”这个 *字符串只是对这种数据结构的一种“编码”* ，就像 ZIP 或者 JPEG 只是对它们压缩的数据的编码一样。

*这种编码可以方便你把代码存到磁盘上，方便你用文本编辑器来修改它们，然而你必须知道，文本并不是代码本身。* 所以从磁盘读取了文本之后，你必须先“解码”，才能方便地操作代码的数据结构。

对于程序语言，这种解码的动作就叫做 _parsing_ ，用于解码的那段代码就叫做 _*parser*_ 。

-----
*2.Parser在编译器中的地位*

那么貌似这样说来，parser 是编译器里面很关键的一个部分了？显然，parser 是必不可少的，然而它并不像很多人想象的那么重要。Parser 的重要性和技术难度，被很多人严重的夸大了。

我喜欢把 parser 称为“万里长征的第 0 步”，因为等你 parse 完毕得到了 AST，真正的编译技术才算开始。

一个编译器包含许多的步骤：语义分析，类型检查/推导，代码优化，机器代码生成，…… 这每个步骤都是在对某种中间数据结构（比如 AST ）进行分析或者转化，它们完全不需要知道代码的字符串形式。也就是说，一旦代码通过了 parser，在后面的编译过程里，你就可以完全忘记 parser 的存在。

Parser 虽然必不可少，然而它比起编译器里面最重要的过程，是处于一种辅助性的地位。

*AST 数据结构才是程序本身，而程序的文本只是这种数据结构的一种编码形式。*

-----
*3.Parser 技术发展的误区*

很多人盲目地设计复杂的语法，然后用越来越复杂的 parser 技术去 parse 它们，这就是 parser 技术仍然在发展的原因。

制造复杂难懂的语法，没有什么真正的好处。不但给程序员的学习造成了不必要的困难，让代码难以理解，而且也给 parser 的作者带来了严重的挑战。

-----
*4.编译原理课程的误导*

#+BEGIN_QUOTE
一般大学里上编译原理课，都是捧着一本大部头的“龙书”或者“虎书”，花掉一个学期 1/3 甚至 2/3 的时间来学写 parser。由于 parser 占据了大量时间，以至于很多真正精华的内容都被一笔带过：语义分析，代码优化，类型推导，静态检查，机器代码生成，…… 以至于很多人上完了编译原理课程，记忆中只留下写 parser 的痛苦回忆。
#+END_QUOTE

我从来就不认为自己是“编译器”专业的，我认为自己是“PL 专业”。编译器领域照本宣科成分更多一些，PL 专业更加注重本质的东西。

如果你想真的深入理解编译理论，最好是从 PL 课程的读物，比如 [[http://www.eopl3.com/][EOPL]] 开始。

#+BEGIN_QUOTE
我可以说 PL 这个领域，真的和编译器的领域很不一样。请不要指望编译器的作者（比如 LLVM 的作者）能够设计出好的语言，因为他们可能根本不理解很多语言设计的东西，他们只是会实现某些别人设计的语言。可是反过来，理解了 PL 的理论， *编译器的东西只不过是把一种语言转换成另外一种语言（机器语言）而已* 。工程的细枝末节很麻烦，可是当你掌握了精髓的原理，那些都容易摸索出来。
#+END_QUOTE

*5.我写 parser 的心得和秘诀*

很多人都觉得写 parser 很难，一方面是由于语言设计的错误思想导致了复杂的语法，另外一方面是由于人们对于 parser 构造过程的思维误区。很多人不理解 parser 的本质和真正的用途，所以他们总是试图让 parser 干一些它们本来不应该干的事情，或者对 parser 有一些不切实际的标准。当然，他们就会觉得 parser 非常难写，非常容易出错。

……

所以你看到了，parser 并不是编译器，它甚至不属于编译里很重要的东西。

Parser 的研究其实是在解决一些根本不存在或者人为制造的问题。复杂的语法导致了复杂的 parser 技术，它们仍然在给计算机世界带来不必要的困扰和麻烦。对 parser 写法的很多误解，过度工程和过早优化，造成了很多人错误的高估写 parser 的难度。

*** TODO [[http://www.yinwang.org/blog-cn/2015/10/18/turing][图灵的光环]]

#+BEGIN_EXPORT html
<essay>
王垠的博文写的真长，一定读了不少的书，并且作了验证（对错暂不论），就这一点也是非常值得学习的。
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy][编程的智慧]]

编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的 *练习和领悟* ，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。

