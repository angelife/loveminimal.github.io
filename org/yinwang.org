#+DATE: <2021-03-03 Wed 10:19>
#+TITLE: 当然我在扯淡

#+BEGIN_QUOTE
我并不喜欢王垠这个人，甚至有些反感，但他的某些博文我很喜欢，也因此而受益，Hmm...
#+END_QUOTE

*Tip. 非原文摘录，各别语句进行了删减和改动，建议看原文（点击章节标题）。

** Blog Excepts

*** [[http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness][什么是“对用户友好”]]

#+BEGIN_EXPORT html
<img
src="images/yinwang-1.jpg"
width="160"
height=""
style="float: right; margin-left: 8px;"
title=""
/>
#+END_EXPORT

#+BEGIN_QUOTE
Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius - and a lot of courage - to move in the opposite direction.

-- Albert Einstein

任何聪明的傻瓜都能把事情做得更大、更复杂、更暴力，而在相反的方向上前进则需要一点天才和很大的勇气。
#+END_QUOTE

“对用户不友好”的背后，其实是程序设计的不合理使得它们 *缺少抽象* ，而不是用户的问题。

#+BEGIN_EXPORT html
<essay>
这点确实，比如，我就总是搞不清楚冰箱中的致冷程度数字、洗衣机面板上的各种设置开关……
</essay>
#+END_EXPORT

如何对用户更加友好呢？ *统一、抽象！*

*** [[http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman][GTF - Great Teacher Friedman]]

程序语言的研究者们往往追逐一些“新概念”，却未能想到很多这些新概念早在几十年前就被 Friedman 想到了。

知识的深度是无止境的。

Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。

在 Friedman 的课上，我利用它们（如 closure 、CPS 等概念）来完成有实际意义的目标，才真正的体会到这些概念的内涵和价值。

#+BEGIN_QUOTE
一个例子就是课程进入到没几个星期的时候，我们开始 *写解释器* 来执行简单的 Scheme 程序。然后我们把这个解释器 *进行 CPS 变换* ，引入全局变量作为 *“寄存器”* (register)，把 CPS 产生的 continuation 转换成 *数据结构（也就是堆栈）* 。最后我们得到的是一个 *抽象机* (abstract machine)，而这在本质上相当于一个真实机器里的中央处理器（CPU）或者虚拟机（比如 JVM）。所以我们其实从无到有，“发明”了 CPU！从这里，我才真正的理解到寄存器，堆栈等的本质，以及我们为什么需要它们。我才真正的明白了，冯诺依曼体系构架为什么要设计成这个样子。后来他让我们去看一篇他的好朋友 Olivier Danvy 的论文，讲述如何从各种不同的解释器经过 CPS 变换得出不同种类的抽象机模型。这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到， *机器并不是计算的本质* 。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料， *我们所要表达的语义，也就是计算的本质，却是不变的。*
#+END_QUOTE

#+BEGIN_QUOTE
当然， *重新发明* 东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是 *独立的思考能力* 。一旦一个东西被你“想”出来，而不是从别人那里 “学”过来，那么你就知道这个想法是 *如何产生* 的。这比起直接学会这个想法要有用很多，因为你知道这里面 *所有的细节和犯过的错误* 。而最重要的，其实是由此得到的 *直觉* 。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文都会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。
#+END_QUOTE

*** [[http://www.yinwang.org/blog-cn/2012/07/25/semantics][什么是语义学]]

*一个程序的“语义” 通常是由另一个程序（“解释器”）决定的 。 _程序只是一个数据结构_ ，通常表示为语法树(abstract syntax tree)或者指令序列* 。这个数据结构本身其实没有意义，是解释器让它产生了意义，对同一个程序可以有不同的解释。

解释器接受一个“程序”(program)，输出一个“值”(value)。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。

CPU 其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。

*所以“语义学”，基本上就是研究各种解释器。*

解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 lambda calculus 的解释器。lambda calculus 只有三种元素，却可以表达所有程序语言的复杂结构。

#+BEGIN_QUOTE
专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《Programming Languages and Lambda Calculi》。只需要看完前半部分（Part I 和 II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是 lambda calculus）开始讲解 *什么是递归定义，什么是解释，什么是 Church-Rosser，什么是上下文 (evaluation context)* 。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 lambda calculus 和 CEK，SECD 等抽象机 (abstract machine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。
#+END_QUOTE

*** TODO [[http://www.yinwang.org/blog-cn/2012/08/01/interpreter][怎样写一个解释器]]

待细读……

*** [[http://www.yinwang.org/blog-cn/2013/03/07/design-patterns][解密设计模式]]

有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）？

总的来说，如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。

可是自从《设计模式》（通常叫做 GoF，“Gang of Four”，“四人帮”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。

#+BEGIN_EXPORT html
<essay>
教条主义不能有！当然，GoF 还是值得读的！
</essay>
#+END_EXPORT

照搬模式东拼西凑，而不能抓住事物的本质，没有“灵感”，其实是设计不出好东西的。

Peter Norvig 在 1998 年就做了一个演讲，指出在“动态语言”里面，GoF 的 20 几个模式，其中绝大部分都“透明”了。也就是说，你根本感觉不到它们的存在。

*** [[http://www.yinwang.org/blog-cn/2013/03/07/linux-windows-mac][谈 Linux, Windows 和 Mac]]

这段时间受到很多人的来信。他们看了我很早以前写的推崇 Linux 的文章，想知道如何“抛弃 Windows，学习 Linux”。天知道他们在哪里找到那么老的文章，真是好事不出门…… 我觉得我有责任消除我以前的文章对人的误导，洗清我这个“Linux 狂热分子”的恶名。

#+BEGIN_EXPORT html
<essay>
Hmm... 我也受这篇文章影响过……
</essay>
#+END_EXPORT

学习操作系统最好的办法是 *学会（真正的）程序设计思想* ，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用程序语言的思想简单的解释。

一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。

#+BEGIN_EXPORT html
<essay>
这里其实是一个悖论，工具实现的其实是心中所想，而如果你要进行精细化的操作，就很难仅用很简单的规则就可以。
</essay>
#+END_EXPORT

有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。

容易的东西不一定是坏的，而困难的东西也不一定是好的。

学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里什么也不会留下。 *学习“原理性”的东西，才是永远不会过时的。*

*** [[http://www.yinwang.org/blog-cn/2013/03/08/on-syntax][谈语法]]

#+BEGIN_EXPORT html
<img
src="http://www.yinwang.org/images/lisp_cycles.png"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

使用和研究过这么多程序语言之后，我觉得几乎不包含多余功能的语言，只有一个： Scheme。

我觉得 Scheme （Lisp） 的基于“S表达式”（S-expression）的语法，是世界上最完美的设计。为什么我喜欢这样一个“全是括号，前缀表达式”的语言呢？这是出于对语言结构本质的考虑。

其实，我觉得语法是完全不应该存在的东西。即使存在，也应该非常的简单。

_语法_ 其实只是对 *语言的本质结构，“抽象语法树”（abstract syntax tree，AST）* 的一种编码。一个良好的编码，应该极度简单，不引起歧义，而且应该容易解码。在程序语言里，这个“解码”的过程叫做“语法分析”（parse）。

为什么我们却又需要语法呢？

因为受到现有工具（操作系统，文本编辑器）的限制，到目前为止，几乎所有语言的程序都是用字符串的形式存放在文件里的。为了 *让字符串能够表示“树”这种结构* ，人们才给程序语言设计了“语法”这种东西。

但是人们喜欢耍小聪明，在有了基本的语法之后，他们开始在这上面大做文章，使得简单的问题变得复杂……

#+BEGIN_EXPORT html
<essay>
语法糖？但有时候真的便捷易用啊……
</essay>
#+END_EXPORT

最老的是 Fortran 的程序，最早的时候都是用打孔机打在卡片上的，所以它其实是几乎没有语法可言的。

#+BEGIN_EXPORT html
<note>
Lisp （Scheme 的前身）是世界上第二老的程序语言。
</note>
#+END_EXPORT

#+BEGIN_EXPORT html
<img
src="http://www.yinwang.org/images/punch-card.gif"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

#+BEGIN_QUOTE
自己想一下，如果要表达一颗“树”，最简单的编码方式是什么？就是用括号把每个节点的“数据”和“子节点”都括起来放在一起。Lisp 的设计者们就是这样想的。他们把这种完全用括号括起来的表达式，叫做“S表达式”（S 代表 “symbolic”）。这貌似很“粗糙”的设计，甚至根本谈不上“设计”。奇怪的是，在用过一段时间之后，他们发现自己已经爱上了这个东西，再也不想设计更加复杂的语法。于是S表达式就沿用至今。
#+END_QUOTE

首先，把所有的结构都用括号括起来，轻松地避免了别的语言里面可能发生的“歧义”。程序员不再需要记忆任何“运算符优先级”。

其次，把“操作符”全都放在表达式的最前面，使得基本算术操作和函数调用，在语法上发生 *完美的统一* ，而且使得程序员可以使用几乎任何符号作为函数名。

#+BEGIN_EXPORT html
<note>
拓展阅读“前缀表达式”和“中缀表达式”相关知识。
</note>
#+END_EXPORT

#+BEGIN_QUOTE
在其他的语言里，函数调用看起来像这个样子： =f(1)= ，而算术操作看起来是这样： =1+2= 。在 Lisp 里面，函数调用看起来是这样 =(f 1)= ，而算术操作看起来也是这样 =(+ 1 2)= 。你发现有什么共同点吗？那就是 =f= 和 =+= 在位置上的对应。实际上，加法在本质也是一个函数。这样做的好处，不但是突出了加法的这一本质，而且它让人可以用跟定义函数一模一样的方式，来定义“运算符”！这比起 C++ 的“运算符重载”强大很多，却又极其简单。
#+END_QUOTE

Lisp 的很多其它的设计，比如“垃圾回收”，后来被很多现代语言（比如 Java）所借鉴。可是人们遗漏了一个很重要的东西：Lisp 的语法，其实才是世界上最好的语法。

#+BEGIN_EXPORT html
<essay>
我也感觉 S-expression 很好用！
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/15/language-design-mistake1][程序语言的常见设计错误(1) - 片面追求短小]]

我的程序的“短小”是建立在 *语义明确，概念清晰* 的基础上的。在此基础上，我力求去掉冗余的，绕弯子的，混淆的代码，让程序更加直接，更加高效的表达我心中设想的“模型”。这是一种在概念级别的优化，而程序的短小精悍只是它的一种“表象”。

我的这种短小往往是在 *语义和逻辑层面* 的，而不是在语法上死抠几行代码。我绝不会为了程序显得短小而让它变得难以理解或者容易出错。

#+BEGIN_EXPORT html
<essay>
文中举了两个小例子，这里只做简要概括。
</essay>
#+END_EXPORT

-----
*1.自增减操作*

从理论上讲， *自增减操作本身就是错误的设计* 。因为它们把对变量的“读”和“写”两种根本不同的操作，毫无原则的合并在一起。这种对读写操作的混淆不清，带来了非常难以发现的错误。相反，一种等价的，“笨”一点的写法， =i = i + 1= ，不但更易理解，而且在逻辑上更加清晰。

有些人很在乎 =i++= 与 =++i= 的区别，去追究 =i++= 与 =++i= 谁的效率更高。这些其实都是徒劳的。比如，i++ 与 ++i 的效率差别，其实来自于早期 C 编译器的愚蠢。

#+BEGIN_EXPORT html
<essay>
以下是正确讲解 i++ 的办法！！！它曾是多少人的痛……
</essay>
#+END_EXPORT

因为 *=i++= 需要在增加之后返回 =i= 原来的值* ，所以它其实被编译为：

#+BEGIN_EXAMPLE
(tmp = i, i = i + 1, tmp)
#+END_EXAMPLE

但是在 =for (int i = 0; i < max; i++)= 中，其实你并不需要在 =i++= 之后得到它自增前的值。所以有人说，在这里应该用 =++i= 而不是 =i++= ，否则你就会浪费一次对中间变量 =tmp= 的赋值。

而其实呢，一个良好设计的编译器应该在两种情况下都生成相同的代码。

#+BEGIN_EXAMPLE
# 在 i++ 的情况，代码其实先被转化为
for (int i = 0; i < max; (tmp = i, i = i + 1, tmp))

# ↓↓↓

# 由于 tmp 这个临时变量从来没被用过，
# 所以它会被编译器的“dead code elimination”消去，
# 编译器最后实际上得到了
for (int i = 0; i < max; i = i + 1)
#+END_EXAMPLE

所以，“精通”这些细微的问题，并不能让你成为一个好的程序员。很多人所认为的高明的技巧，经常都是因为早期系统设计的缺陷所致。一旦这些系统被改进，这些技巧就没什么用处了。

真正正确的做法其实是：完全不使用自增减操作，因为它们本来就是错误的设计。

-----
*2.赋值语句返回值*

在几乎所有像 C，C++，Java 的语言里，赋值语句都可以被作为值。

=y = 0= 不应该具有一个值。它的作用应该是“赋值”这种“动作”，而不应该具有任何“值”。即使牵强一点硬说它有值，它的值也应该是 =void= 。这样一来 =x = y = 0= 和 =if (y = 0)= 就会因为“类型不匹配”而被编译器拒绝接受，从而避免了可能出现的错误。

#+BEGIN_EXPORT html
<essay>
if (y == 0) 写成 if (y = 0) ，Hmm……
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/19/eliminate-problems][“解决问题”与“消灭问题”]]

如果你仔细观察就会发现，很多“难题”，其实是“人造”出来的，而不是“必然”的。它们的存在，往往是由于一些早期的“设计错误”。

如果我们转换一下思路，或者改变一下“设计”，很多问题就可以不解自消。这就是我所谓的“消灭问题”的能力。

所以，在解决问题之前，我们应该先问自己三个问题：

1. 这问题是否真的“存在”？
2. 如果解决了这个问题，会给我和他人在合理的时间之内带来什么实际的好处？
3. 这问题是否可以在简单的改变某些“设计”或者“思路”之后，不复存在？

#+BEGIN_EXPORT html
<essay>
本质上是认真思考一下问题产生的原因！
</essay>
#+END_EXPORT

*** [[http://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive][Lisp 已死，Lisp 万岁！]]

*Lisp 的优点：*

Lisp 的语法是世界上最精炼，最美观，也是语法分析起来最高效的语法。这是 Lisp 独一无二的，其他语言都没有的优点。有些人喜欢设计看起来很炫的语法，其实都是自找麻烦。为什么这么说呢，请参考这篇[[http://www.yinwang.org/blog-cn/2013/03/08/on-syntax][《谈语法》]] 。

Lisp 是第一个可以 *在程序的任何位置定义函数* ，并且可以 *把函数作为值传递* 的语言。这样的设计使得它的表达能力非常强大。这种理念被 Python，JavaScript，Ruby 等语言所借鉴。

Lisp 有世界上最强大的宏系统（macro system）。这种宏系统的表达力几乎达到了理论所允许的极限。如果你只见过 C 语言的“宏”，那我可以告诉你它是完全没法跟 Lisp 的宏系统相提并论的。

Lisp 是世界上第一个使用垃圾回收（ garbage collection）的语言。这种超前的理念，后来被 Java，C# 等语言借鉴。

#+BEGIN_QUOTE
想不到吧，现代语言的很多优点，其实都是来自于 Lisp — 世界上第二古老的程序语言。所以有人才会说，每一种现代语言都在朝着 Lisp 的方向“进化”。

如果你相信了这话，也许就会疑惑，为什么 Lisp 今天没有成为主流？为什么 Lisp Machine 会被 Unix 打败？其实除了商业原因之外，还有技术上的问题。
#+END_QUOTE

早期的 Lisp 其实普遍存在一个非常严重的问题：它使用 *dynamic scoping* 。

所谓 dynamic scoping 就是说，如果你的函数定义里面有 *“自由变量”* ，那么这个自由变量的值，会随着函数的“调用位置”的不同而发生变化。
