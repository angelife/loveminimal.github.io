#+DATE: <2021-03-17 Wed 16:21>
#+TITLE: Vue Inbox

** Vue Inbox

*** 声明式渲染

Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。

数据和 DOM 已经被建立了关联，所有东西都是响应式的。

我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上，然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。

*** 处理用户输入

为了让用户和你的应用进行交互，我们可以用 =v-on= 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法。

Vue 还提供了 =v-model= 指令，它能轻松实现表单输入和应用状态之间的双向绑定。

*** 组件化应用构建

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。

在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。

*** Vue 实例

*创建一个 Vue 实例*

每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的，当创建一个 Vue 实例时，你可以传入一个 *选项对象* 。

一个 Vue 应用由一个通过 =new Vue= 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。

-----
*数据与方法*

当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。

*值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。

使用 =Object.freeze()= ，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 =$= ，以便与用户定义的 property 区分开来。

*** 模板语法

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。

如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。

更多关于 [[https://cn.vuejs.org/v2/guide/render-function.html][渲染函数 & JSX]] 。

数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。

Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 =v-bind= 指令。

实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。

*限制就是，每个绑定都只能包含单个表达式。

一些指令能够接收一个“参数”，在指令名称之后以冒号表示。如：

#+BEGIN_SRC html -n
<a v-bind:href="url">...</a>
<a v-on:click="doSomething">...</a>
#+END_SRC

从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数。

#+BEGIN_SRC html -n
  <!-- （动态参数） -->
  <a v-bind:[attributeName]="url"> ... </a>
#+END_SRC

动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。

修饰符 (modifier) 是以半角句号 =.= 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如， =.prevent= 修饰符告诉 v-on 指令对于触发的事件调用 =event.preventDefault()= 。

*** 计算属性

模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。

#+BEGIN_EXPORT html
<essay>
编写代码一定要注意语义表述的简洁性和可读性。
</essay>
#+END_EXPORT

*对于任何复杂逻辑，你都应当使用计算属性。

你可以像绑定普通 property 一样在模板中绑定计算属性。计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。

*计算属性缓存 vs 方法*

我们可以将同一函数定义为一个方法而不是一个计算属性。不同的是 *计算属性是基于它们的响应式依赖进行缓存的* ，只在相关响应式依赖发生改变时它们才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

计算属性默认只有 getter，不过在需要时你也可以提供一个 setter 。

*计算属性 vs 侦听属性*

Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。

！当需要在数据变化时执行异步或开销较大的操作时，这个方式（侦听属性）是最有用的。

使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

*** 绑定 HTML Class

在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。

#+BEGIN_EXPORT html
<essay>
结构化的数据总是更便于处理的。
</essay>
#+END_EXPORT

*1.对象语法*

我们可以传给 =v-bind:class= 一个对象，以动态地切换 class：

#+BEGIN_SRC html -n
  <div v-bind:class="{ active: isActive }"></div>

  <!-- 可以在对象中传入更多字段来动态切换多个 class -->
  <div
    class="static"
    v-bind:class="{ active: isActive, 'text-danger': hasError }"
  ></div>
#+END_SRC

绑定的数据对象不必内联定义在模板里：

#+BEGIN_SRC js -n
// <div v-bind:class="classObject"></div>

data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
#+END_SRC

我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式：

#+BEGIN_SRC js -n
// <div v-bind:class="classObject"></div>

data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
#+END_SRC

-----
*2.数组语法*

我们可以把一个数组传给 v-bind:class，以应用一个 class 列表：

#+BEGIN_SRC js -n
// <div v-bind:class="[activeClass, errorClass]"></div>

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
#+END_SRC

渲染为：

#+BEGIN_SRC html -n
<div class="active text-danger"></div>
#+END_SRC

在数组语法中也可以使用对象语法：

#+BEGIN_SRC html -n
  <!-- <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div> -->
  <!-- 等价于 -->
  <div v-bind:class="[{ active: isActive }, errorClass]"></div>
#+END_SRC

-----
*3.用在组件上*

当在一个自定义组件上使用 class property 时，这些 class 将被添加到该 *组件的根元素* 上面。这个元素上已经存在的 class 不会被覆盖。

*** 绑定内联样式

*1.对象语法*

=v-bind:style= 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。

CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：

#+BEGIN_SRC js -n
// <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

data: {
  activeColor: 'red',
  fontSize: 30
}
#+END_SRC

直接绑定到一个样式对象通常更好，这会让模板更清晰：

#+BEGIN_SRC js -n
// <div v-bind:style="styleObject"></div>

data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
#+END_SRC

同样的，对象语法常常结合返回对象的计算属性使用。

-----
*2.数组语法*

v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：

#+BEGIN_SRC html -n
<div v-bind:style="[baseStyles, overridingStyles]"></div>
#+END_SRC

*** 条件渲染和列表渲染

Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可。

#+BEGIN_SRC html -n
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
#+END_SRC

当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将 *不会移动 DOM 元素来匹配数据项的顺序* ，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

*这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：

#+BEGIN_SRC html -n
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
#+END_SRC

*不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。

-----
*数组更新检测*

Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：

#+BEGIN_EXAMPLE
- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
#+END_EXAMPLE

变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 =filter()、concat()= 和 =slice()= 。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：

#+BEGIN_SRC js -n
example1.items = example1.items.filter(function (item) {
    return item.message.match(/Foo/)
})
#+END_SRC

*！由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。*

-----
*显示过滤/排序后的结果*

有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。

在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：

#+BEGIN_SRC js -n
// <ul v-for="set in sets">
//  <li v-for="n in even(set)">{{ n }}</li>
// </ul>

data: {
  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
#+END_SRC

v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。

类似于 v-if，你也可以利用带有 v-for 的 <template> 来循环渲染一段包含多个元素的内容。

-----
*v-for 与 v-if 一同使用*

当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用。而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <template>) 上。

-----
*在组件上使用 v-for*

在自定义组件上，你可以像在任何普通元素上一样使用 v-for。然而，任何数据都不会被自动传递到组件里，因为 *组件有自己独立的作用域* 。 *为了把迭代数据传递到组件里，我们要使用 prop* 。

#+BEGIN_QUOTE
不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。 *明确组件数据的来源能够使组件在其他场合重复使用* 。
#+END_QUOTE

*** 事件处理

可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。

然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收 *一个需要调用的方法名称* 。

除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法。

#+BEGIN_SRC html -n
  <button v-on:click="counter += 1">Add 1</button>

  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>

 <button v-on:click="say('hi')">Say hi</button>
#+END_SRC

*有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 =$event= 把它传入方法：*

#+BEGIN_SRC js -n
// <button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>

// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
#+END_SRC

-----
*事件修饰符*

在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。

尽管我们可以在方法中轻松实现这点，但更好的方式是： *方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。*

为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。

#+BEGIN_EXAMPLE
- .stop
- .prevent
- .capture
- .self
- .once
- .passive
#+END_EXAMPLE

#+BEGIN_SRC html -n
  <!-- 阻止单击事件继续传播 -->
  <a v-on:click.stop="doThis"></a>

  <!-- 提交事件不再重载页面 -->
  <form v-on:submit.prevent="onSubmit"></form>

  <!-- 修饰符可以串联 -->
  <a v-on:click.stop.prevent="doThat"></a>

  <!-- 只有修饰符 -->
  <form v-on:submit.prevent></form>

  <!-- 添加事件监听器时使用事件捕获模式 -->
  <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
  <div v-on:click.capture="doThis">...</div>

  <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
  <!-- 即事件不是从内部元素触发的 -->
  <div v-on:click.self="doThat">...</div>

  <!-- 点击事件将只会触发一次 -->
  <a v-on:click.once="doThis"></a>

  <!-- Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符 -->
  <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
  <!-- 而不会等待 `onScroll` 完成  -->
  <!-- 这其中包含 `event.preventDefault()` 的情况 -->
  <div v-on:scroll.passive="onScroll">...</div>
#+END_SRC

#+BEGIN_QUOTE
使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 =v-on:click.prevent.self= 会阻止所有的点击，而 =v-on:click.self.prevent= 只会阻止对元素自身的点击。
#+END_QUOTE

*** 表单输入绑定

你可以用 v-model 指令在表单 =<input>、<textarea>= 及 =<select>= 元素上创建双向数据绑定。

它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。 *它负责监听用户的输入事件以更新数据* ，并对一些极端场景进行一些特殊处理。

#+BEGIN_QUOTE
v-model 会忽略所有表单元素的 =value、checked、selected= attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。
#+END_QUOTE

v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：
- text 和 textarea 元素使用 =value= property 和 =input= 事件；
- checkbox 和 radio 使用 =checked= property 和 =change= 事件；
- select 字段将 =value= 作为 prop 并将 =change= 作为事件。

#+BEGIN_QUOTE
对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。
#+END_QUOTE

*** 组件基础

组件是可复用的 Vue 实例，且带有一个名字，它们与 new Vue 接收相同的选项，例如 =data、computed、watch、methods= 以及生命周期钩子等。

*仅有的例外是像 =el= 这样根实例特有的选项。

*一个组件的 data 选项必须是一个函数* ，因此每个实例可以维护一份被返回对象的独立的拷贝。

为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。

全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。

-----
*通过 Prop 向子组件传递数据*

Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。

#+BEGIN_SRC js -n
  // 全局注册 `blog-post` 组件
  Vue.component('blog-post', {
    props: ['title'],
    template: '<h3>{{ title }}</h3>'
  })

  // 一个 prop 被注册之后，你就可以像这样把数据作为一个自定义 attribute 传递进来
  // <blog-post title="My journey with Vue"></blog-post>
  // <blog-post title="Blogging with Vue"></blog-post>
#+END_SRC

*我们能够在组件实例中访问这个值，就像访问 data 中的值一样。

一个组件默认可以拥有任意数量的 prop， *任何值* 都可以传递给任何 prop。

*！每个组件必须只有一个根元素。*

-----
*监听子组件事件*

在我们开发 =<blog-post>= 组件时，它的一些功能可能要求我们和父级组件进行沟通。例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号。

Vue 实例提供了一个自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：

#+BEGIN_SRC html -n
<blog-post
  ...
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
#+END_SRC

同时子组件可以通过调用内建的 =$emit= 方法并传入事件名称来触发一个事件：

#+BEGIN_SRC html -n
<button v-on:click="$emit('enlarge-text')">
  Enlarge text
</button>
#+END_SRC

-----
*使用事件抛出一个值*

有的时候用一个事件来抛出一个特定的值是非常有用的。

例如我们可能想让 =<blog-post>= 组件决定它的文本要放大多少。这时可以使用 =$emit= 的第二个参数来提供这个值：

#+BEGIN_SRC html -n
<button v-on:click="$emit('enlarge-text', 0.1)">
  Enlarge text
</button>
#+END_SRC

然后当在 *父级组件监听这个事件* 的时候，我们 *可以通过 =$event= 访问到被抛出的这个值* ：

#+BEGIN_SRC html -n
<blog-post
  ...
  v-on:enlarge-text="postFontSize += $event"
></blog-post>
#+END_SRC

或者，如果这个事件处理函数是 *一个方法* ，那么这个值将会 *作为第一个参数传入这个方法* ：

#+BEGIN_SRC js -n
// <blog-post
//   ...
//   v-on:enlarge-text="onEnlargeText"
// ></blog-post>

methods: {
  onEnlargeText: function (enlargeAmount) {
    this.postFontSize += enlargeAmount
  }
}
// `enlargeAmount` 就是组件抛出来的值
#+END_SRC

-----
*通过插槽分发内容*

和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：

#+BEGIN_SRC html -n
<alert-box>
  Something bad happened.
</alert-box>
#+END_SRC

幸好，Vue 自定义的 <slot> 元素让这变得非常简单：

#+BEGIN_SRC js -n
Vue.component('alert-box', {
  template: `
    <div class="demo-alert-box">
      <strong>Error!</strong>
      <slot></slot>
    </div>
  `
})
#+END_SRC

-----
*动态组件*

在不同组件之间进行动态切换是非常有用的，可以通过 Vue 的 =<component>= 元素加一个特殊的 =is= attribute 来实现，如：

#+BEGIN_SRC html -n
<!-- 组件会在 `currentTabComponent` 改变时改变 -->
<component v-bind:is="currentTabComponent"></component>
#+END_SRC

*？请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 =value= 这样的 property，若想让其如预期般工作，你需要使用 =.prop= 修饰器。

有些 HTML 元素，诸如 =<ul>、<ol>、<table>= 和 =<select>= ，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 =<li>、<tr>= 和 =<option>= ，只能出现在其它某些特定的元素内部。

这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：

#+BEGIN_SRC html -n
<table>
  <blog-post-row></blog-post-row>
</table>
#+END_SRC

这个自定义组件 =<blog-post-row>= 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 =is= attribute 给了我们一个变通的办法：

#+BEGIN_SRC html -n
<table>
  <tr is="blog-post-row"></tr>
</table>
#+END_SRC

需要注意的是 *如果我们从以下来源使用模板的话，这条限制是不存在的：*
- 字符串 (例如： =template: '...'= )
- 单文件组件 (=.vue=)
- ~<script type="text/x-template">~

到这里，你需要了解的解析 DOM 模板时的注意事项——实际上也是 Vue 的全部必要内容，大概就是这些了。恭喜你！

** 深入了解组件
