<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-04-13 Tue 17:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java Inbox</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="themes/assets/rose-red.png" type="image/x-icon" />
           <link rel="stylesheet" href="themes/style.css" type="text/css"  />
           <script type="module" src="themes/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">Java Inbox</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf13ff14">面向对象</a>
<ul>
<li><a href="#orgb56b75f">模块</a></li>
</ul>
</li>
<li><a href="#org2f0a024">反射</a>
<ul>
<li><a href="#org6a33c90">Class 类</a></li>
</ul>
</li>
<li><a href="#org8964923">Maven</a>
<ul>
<li><a href="#org40d9289">为什么需要 Maven</a></li>
<li><a href="#org7481515">Maven 项目结构</a></li>
<li><a href="#org481da97">项目描述文件</a></li>
<li><a href="#org205e806">依赖管理</a></li>
<li><a href="#orgc35302f">Maven 镜像</a></li>
<li><a href="#org432e165"><span class="todo TODO">TODO</span> 构建流程</a></li>
</ul>
</li>
<li><a href="#org548f703"><span class="todo TODO">TODO</span> 多线程</a>
<ul>
<li><a href="#org5b1528c">线程和进程</a></li>
<li><a href="#org132c096">创建新线程</a></li>
<li><a href="#orgac1864a">线程的状态</a></li>
<li><a href="#org0328e5b">中断线程</a></li>
<li><a href="#org2cf9f0d">守护进程</a></li>
<li><a href="#orgf03d9cb">线程同步</a></li>
<li><a href="#org0411443">同步方法</a></li>
</ul>
</li>
<li><a href="#orgbabdd5c">JDBC 编程</a>
<ul>
<li><a href="#orgeb7736c">关系数据库</a></li>
<li><a href="#org73fe419">JDBC 操作</a></li>
<li><a href="#org462f421">JDBC 事务</a></li>
<li><a href="#orgb7736d1">JDBC Batch</a></li>
<li><a href="#org34af4ce">JDBC 连接池</a></li>
</ul>
</li>
<li><a href="#org90abfd7">Web 开发</a>
<ul>
<li><a href="#orgb441b15">JavaEE</a></li>
<li><a href="#orgece8e66">Web 基础</a></li>
<li><a href="#orgb8fc0b3">Servlet</a></li>
<li><a href="#org63879d3">Servlet 开发</a></li>
</ul>
</li>
<li><a href="#org6cfe720">Spring 开发</a>
<ul>
<li><a href="#orga557055">AOP 本质</a></li>
<li><a href="#orgc20326a">装配 AOP</a></li>
<li><a href="#orgce4866b">AOP 避坑指南</a></li>
<li><a href="#orgb597d13">访问数据库</a></li>
<li><a href="#org04c4606"><span class="todo TODO">TODO</span> 使用 JDBC</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
→ 摘录自廖雪峰老师的 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a>
</p>

<div id="outline-container-orgf13ff14" class="outline-2">
<h2 id="orgf13ff14">面向对象</h2>
<div class="outline-text-2" id="text-orgf13ff14">
</div>
<div id="outline-container-orgb56b75f" class="outline-3">
<h3 id="orgb56b75f">模块</h3>
<div class="outline-text-3" id="text-orgb56b75f">
<p>
<b>为什么需要模块？</b>
</p>

<p>
<code>.class</code> 文件是 JVM 看到的最小可执行文件，jar 是用于存放 class 的容器，它并不关心 class 之间的依赖。
</p>

<p>
从Java 9开始引入了自带“依赖关系”的 class 容器 &#x2013; <b>模块</b> 。
</p>

<p>
<b>如何编写模块呢？</b>
</p>

<img
src="images/java-42.png"
width="660"
height=""
style=""
title=""
/>

<p>
仅仅在 <code>src</code> 目录下多了一个 <code>module-info.java</code> 这个文件，这就是模块的描述文件。如：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">module</span> hello.<span style="color: SystemWindowText;">world</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">base</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21487;&#19981;&#20889;&#65292;&#20219;&#20309;&#27169;&#22359;&#37117;&#20250;&#33258;&#21160;&#24341;&#20837;java.base</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">xml</span>;
<span class="linenr">4: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
*当我们使用模块声明了依赖关系后，才能使用引入的模块。
</p>

<p>
<b>模块有什么用？</b>
</p>

<p>
我们可以用它来打包 JRE ！
</p>

<p>
模块进一步隔离了代码的访问权限，只有它声明的导出的包，外部代码才被允许访问。
</p>
</div>
</div>
</div>

<div id="outline-container-org2f0a024" class="outline-2">
<h2 id="org2f0a024">反射</h2>
<div class="outline-text-2" id="text-org2f0a024">
<p>
反射就是 Reflection， Java 的反射是指程序在运行期（对某个实例一无所知的情况下）可以拿到一个对象的所有信息。
</p>
</div>

<div id="outline-container-org6a33c90" class="outline-3">
<h3 id="org6a33c90">Class 类</h3>
<div class="outline-text-3" id="text-org6a33c90">
<p>
除了 <code>int</code> 等基本类型外，Java 的其他类型全部都是 <code>class</code> （包括 <code>interface</code> ）。
</p>

<p>
<code>class</code> 是由 JVM 在执行过程中动态加载的。 JVM 在第一次读取到一种 <code>class</code> 类型时，将其加载进内存。
</p>

<p>
<b>每加载一种 <code>class</code> ，JVM 就为其创建一个 <code>Class</code> 类型的实例，</b> 并关联进来。
这里的 <code>Class</code> 类型是一个名叫 "Class" 的 <code>class</code> 。它长这样：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">final</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Class</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>    <span style="color: #a020f0;">private</span> <span style="color: SystemWindowText;">Class</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{}</span>
<span class="linenr">3: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
这个 <code>Class</code> 实例是 JVM 内部创建的，可以发现 <code>Class</code> 类的构造方法是 <code>private</code> ，只有 JVM 能创建 <code>Class</code> 实例，我们自己的 Java 程序是无法创建 <code>Class</code> 实例的。
</p>

<p>
<b>*JVM持有的每个 <code>Class</code> 实例都指向一个数据类型（ <code>class</code> 或 <code>interface</code> ）。</b>
</p>

<p>
一个 <code>Class</code> 实例包含了该 <code>class</code> 的所有完整信息：
</p>

<img
src="images/java-50.jpg"
width="420"
height=""
style=""
title=""
/>

<p>
由于 JVM 为每个加载的 <code>class</code> 创建了对应的 <code>Class</code> 实例，并在实例中保存了该 <code>class</code> 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应的 <code>class</code> 的所有信息。
</p>

<blockquote>
<p>
这种通过 <code>Class</code> 实例获取 <code>class</code> 信息的方法称为反射 （Reflection）。
</p>
</blockquote>

<p>
如何获取一个 <code>class</code> 的 <code>Class</code> 实例？有三个方法：
</p>
<ol class="org-ol">
<li>直接通过一个 <code>class</code> 的静态变量 <code>class</code> 获取；</li>
<li>通过实例变量（如果有）提供的 <code>getClass()</code> 方法获取；</li>
<li>如果知道一个 <code>class</code> 的完整类名，通过静态方法 <code>Class.forName()</code> 获取。</li>
</ol>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">1</span>
<span class="linenr">2: </span><span style="color: #a020f0;">Class</span> <span style="color: SystemWindowText;">cls</span> = String.<span style="color: #a020f0;">class</span>;
<span class="linenr">3: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">2</span>
<span class="linenr">4: </span><span style="color: #a020f0;">String</span> <span style="color: SystemWindowText;">s</span> = <span style="color: #8b2252;">"Hello"</span>;
<span class="linenr">5: </span><span style="color: #a020f0;">Class</span> <span style="color: SystemWindowText;">cls</span> = s.getClass<span style="color: #707183;">()</span>;
<span class="linenr">6: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">3</span>
<span class="linenr">7: </span><span style="color: #a020f0;">Class</span> <span style="color: SystemWindowText;">cls</span> = Class.forName<span style="color: #707183;">(</span><span style="color: #8b2252;">"java.lang.String"</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>Class</code> 实例在 JVM 中是唯一的，所以，上述方法获取的 <code>Class</code> 实例是同一个实例。
</p>

<p>
JVM 为每一种基本类型如 <code>int</code> 也创建了 <code>Class</code> ，通过 <code>int.class</code> 访问。
</p>

<p>
JVM 总是动态加载 <code>class</code> ，可以在运行期根据条件来控制加载 <code>class</code> 。
</p>
</div>
</div>
</div>

<div id="outline-container-org8964923" class="outline-2">
<h2 id="org8964923">Maven</h2>
<div class="outline-text-2" id="text-org8964923">
<p>
Maven 是一个 Java 项目管理和构建工具，它可以定义 <span class="underline">项目结构</span> 、 <span class="underline">项目依赖</span> ，并且用统一的方式进行 <span class="underline">自动化构建</span> （编译、测试、打包、发布……）。
</p>

<essay>
在标准化这件事上，真是你好、我好、大家好！
</essay>
</div>

<div id="outline-container-org40d9289" class="outline-3">
<h3 id="org40d9289">为什么需要 Maven</h3>
<div class="outline-text-3" id="text-org40d9289">
<p>
一个 Java 项目需要什么？
</p>

<p>
首先，确定 <b>目录结构</b> 。
</p>

<p>
其次，我们需要确定 <b>引入哪些依赖包</b> ，并把它们加入 classpath 。
</p>

<p>
此外，还需要配置环境，例如 JDK 的版本，编译打包的流程，当前代码的版本号。
</p>

<p>
如果你不使用 IDE ，那么我们就不得不使用命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。
</p>

<p>
这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。
</p>

<essay>
哎，多项目，不标准化，真的是一言难尽……
</essay>
</div>
</div>

<div id="outline-container-org7481515" class="outline-3">
<h3 id="org7481515">Maven 项目结构</h3>
<div class="outline-text-3" id="text-org7481515">
<img
src="images/java-47.jpg"
width="200"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
项目的根目录 <code>a-maven-project</code> 是项目名，它有一个项目描述文件 <code>pom.xml</code> ，存放 Java 源码的目录是 <code>src/main/java</code> ，存放资源文件的目录是 <code>src/main/resources</code> ，存放测试源码的目录是 <code>src/test/java</code> ，存放资源的目录是 <code>src/test/resources</code> ，最后，所有编译、打包生成的文件都放在 <code>target</code> 目录里。
</p>

<p>
所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven 就可以正常使用。
</p>

<essay>
确定的目录结构，对于 Maven 来说也是必须的，因为实现 Maven 这个工具本身也需要按照相对确定的路径来扫描所要使用的文件。
</essay>
</div>
</div>

<div id="outline-container-org481da97" class="outline-3">
<h3 id="org481da97">项目描述文件</h3>
<div class="outline-text-3" id="text-org481da97">
<p>
POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个 XML 文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。
</p>

<p>
执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。
</p>

<p>
<b>所有 POM 文件都需要 <code>project</code> 元素和三个必需字段： <code>groupId，artifactId，version</code> 。</b>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project</span> <span style="color: #a020f0;">xmlns</span> = <span style="color: #8b2252;">"http://maven.apache.org/POM/4.0.0"</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">xmlns</span>:<span style="color: SystemWindowText;">xsi</span> = <span style="color: #8b2252;">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="linenr"> 3: </span>    <span style="color: #a020f0;">xsi</span>:<span style="color: SystemWindowText;">schemaLocation</span> = <span style="color: #8b2252;">"http://maven.apache.org/POM/4.0.0</span>
<span class="linenr"> 4: </span><span style="color: #8b2252;">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#27169;&#22411;&#29256;&#26412; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr"> 7: </span>    &lt;<span style="color: SystemWindowText;">modelVersion</span>&gt;4.0.0&lt;/<span style="color: SystemWindowText;">modelVersion</span>&gt;
<span class="linenr"> 8: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#20844;&#21496;&#25110;&#32773;&#32452;&#32455;&#30340;&#21807;&#19968;&#26631;&#24535;&#65292;&#24182;&#19988;&#37197;&#32622;&#26102;&#29983;&#25104;&#30340;&#36335;&#24452;&#20063;&#26159;&#30001;&#27492;&#29983;&#25104;&#65292;</span>
<span class="linenr"> 9: </span><span style="color: #7f7f7f;">         &#22914;com.companyname.project-group&#65292;</span>
<span class="linenr">10: </span><span style="color: #7f7f7f;">         maven&#20250;&#23558;&#35813;&#39033;&#30446;&#25171;&#25104;&#30340;jar&#21253;&#25918;&#26412;&#22320;&#36335;&#24452;&#65306;/com/companyname/project-group </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">11: </span>    &lt;<span style="color: SystemWindowText;">groupId</span>&gt;com.companyname.project-group&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#39033;&#30446;&#30340;&#21807;&#19968;ID&#65292;&#19968;&#20010;groupId&#19979;&#38754; _&#21487;&#33021;&#22810;&#20010;&#39033;&#30446;_&#65292;&#23601;&#26159;&#38752;artifactId&#26469;&#21306;&#20998;&#30340; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">14: </span>    &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;project&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#29256;&#26412;&#21495; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">17: </span>    &lt;<span style="color: SystemWindowText;">version</span>&gt;1.0&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr">18: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<hr>
<p>
<b>Super POM</b>
</p>

<p>
所有的 POM 都继承自一个 <b>父 POM（Super POM）</b> （无论是否显式定义了这个父 POM）。
</p>

<p>
父 POM 包含了一些可以被继承的默认设置，使用 <code>mvn help:effective-pom</code> 命令来查看 Super POM 默认配置。
</p>

<blockquote>
<p>
Maven 使用 <code>effective pom</code> （Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 <code>pom.xml</code> 中做尽可能少的配置，当然这些配置可以被重写。
</p>
</blockquote>

<p>
你可以看到 Maven 在执行目标时需要用到的默认工程源码目录结构、输出目录、需要的插件、仓库和报表目录。
</p>

<p>
详细的 <code>pom.xml</code> 配置请查看 <a href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a>
</p>

<hr>
<p>
<b>Maven 依赖</b>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project...</span>&gt;
<span class="linenr"> 2: </span>    ...
<span class="linenr"> 3: </span>    &lt;<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr"> 4: </span>        &lt;<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 5: </span>            &lt;<span style="color: SystemWindowText;">groupId</span>&gt;commons-logging&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr"> 6: </span>            &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;commons-logging&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr"> 7: </span>            &lt;<span style="color: SystemWindowText;">version</span>&gt;1.2&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr"> 8: </span>        &lt;/<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 9: </span>        ...
<span class="linenr">10: </span>    &lt;/<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr">11: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<p>
使用 <code>&lt;dependency&gt;</code> 声明一个依赖后，Maven 就会自动下载这个依赖包并把它放到 classpath 中。 Maven使用 <code>groupId，artifactId</code> 和 <code>version</code> 唯一定位一个依赖。
</p>
</div>
</div>

<div id="outline-container-org205e806" class="outline-3">
<h3 id="org205e806">依赖管理</h3>
<div class="outline-text-3" id="text-org205e806">
<p>
Maven 的第一个作用就是解决依赖管理。我们声明了自己的项目需要 <code>abc</code> ，Maven会自动导入 <code>abc</code> 的 jar包，再判断出 <code>abc</code> 需要 <code>xyz</code> ，又会自动导入 <code>xyz</code> 的jar包 ……
</p>

<p>
如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。
</p>

<p>
<b>依赖关系</b>
</p>

<p>
Maven定义了几种依赖关系，分别是 <code>compile、test、runtime</code> 和 <code>provided</code> 。
</p>

<p>
默认的 <code>compile</code> 是最常用的，Maven会把这种类型的依赖直接放入 classpath 。
</p>

<p>
<code>test</code> 依赖表示仅在测试时使用，正常运行时并不需要，如 JUnit 。
</p>

<p>
<code>runtime</code> 依赖表示编译时不需要，但运行时需要。最典型的 <code>runtime</code> 依赖是 JDBC 驱动，例如 MySQL驱动。
</p>

<p>
<code>provided</code> 依赖表示编译时需要，但运行时不需要。最典型的 <code>provided</code> 依赖是 <code>Servlet API</code> ，编译的时候需要，但是运行时，Servlet服务器内置了相关的 jar，所以运行期不需要。
</p>

<essay>
比如，运行的时候，Servlet 容器 Tomcat 会提供相关的 Servlet API 。
</essay>

<p>
<b>搜索第三方组件</b>
</p>

<p>
通过 <a href="https://search.maven.org/">search.maven.org</a> 搜索关键字，找到对应的组件后，直接复制。
</p>
</div>
</div>

<div id="outline-container-orgc35302f" class="outline-3">
<h3 id="orgc35302f">Maven 镜像</h3>
<div class="outline-text-3" id="text-orgc35302f">
<p>
中国区用户可以使用阿里云提供的 Maven 镜像仓库。使用 Maven 镜像仓库需要一个配置，在用户主目录下进入 <code>.m2</code> 目录，创建一个 <code>settings.xml</code> 配置文件，内容如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">settings</span>&gt;
<span class="linenr"> 2: </span>    &lt;<span style="color: SystemWindowText;">mirrors</span>&gt;
<span class="linenr"> 3: </span>        &lt;<span style="color: SystemWindowText;">mirror</span>&gt;
<span class="linenr"> 4: </span>            &lt;<span style="color: SystemWindowText;">id</span>&gt;aliyun&lt;/<span style="color: SystemWindowText;">id</span>&gt;
<span class="linenr"> 5: </span>            &lt;<span style="color: SystemWindowText;">name</span>&gt;aliyun&lt;/<span style="color: SystemWindowText;">name</span>&gt;
<span class="linenr"> 6: </span>            &lt;<span style="color: SystemWindowText;">mirrorOf</span>&gt;central&lt;/<span style="color: SystemWindowText;">mirrorOf</span>&gt;
<span class="linenr"> 7: </span>            <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#22269;&#20869;&#25512;&#33616;&#38463;&#37324;&#20113;&#30340;Maven&#38236;&#20687; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr"> 8: </span>            &lt;<span style="color: SystemWindowText;">url</span>&gt;https://maven.aliyun.com/repository/central&lt;/<span style="color: SystemWindowText;">url</span>&gt;
<span class="linenr"> 9: </span>        &lt;/<span style="color: SystemWindowText;">mirror</span>&gt;
<span class="linenr">10: </span>    &lt;/<span style="color: SystemWindowText;">mirrors</span>&gt;
<span class="linenr">11: </span>&lt;/<span style="color: SystemWindowText;">settings</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org432e165" class="outline-3">
<h3 id="org432e165"><span class="todo TODO">TODO</span> 构建流程</h3>
<div class="outline-text-3" id="text-org432e165">
<p>
……
</p>
</div>
</div>
</div>

<div id="outline-container-org548f703" class="outline-2">
<h2 id="org548f703"><span class="todo TODO">TODO</span> 多线程</h2>
<div class="outline-text-2" id="text-org548f703">
</div>
<div id="outline-container-org5b1528c" class="outline-3">
<h3 id="org5b1528c">线程和进程</h3>
<div class="outline-text-3" id="text-org5b1528c">
<p>
进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。
</p>

<img
src="images/java-43.jpg"
width="660"
height=""
style=""
title=""
/>

<p>
操作系统调度的最小任务单位其实不是进程，而是线程。
</p>

<p>
相对进程来说，创建线程开销小、通信快（线程间通信就是读写同一个变量）。多进程的好处在于稳定性好，一个进程崩溃不会影响其他进程。
</p>

<p>
Java 语言内置了多线程的支持：一个 Java 程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行 <code>main()</code> 方法，在 <code>main()</code> 方法内部，我们又可以启动多个线程。此外，JVM 还有负责垃圾回收的其他工作线程等。
</p>

<p>
因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。
</p>

<p>
Java多线程编程的特点又在于：
</p>

<ul class="org-ul">
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
</div>
</div>

<div id="outline-container-org132c096" class="outline-3">
<h3 id="org132c096">创建新线程</h3>
<div class="outline-text-3" id="text-org132c096">
<p>
要创建一个新线程非常容易，我们需要实例化一个 <code>Thread</code> 实例，然后调用它的 <code>start()</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Main</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">main</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">String</span><span style="color: #909183;">[]</span> <span style="color: SystemWindowText;">args</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">Thread</span><span style="color: #909183;">()</span>;
<span class="linenr">4: </span>        t.start<span style="color: #909183;">()</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21551;&#21160;&#26032;&#32447;&#31243;</span>
<span class="linenr">5: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">6: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
但是这个线程启动后实际上什么也不做就立刻结束了。
</p>

<p>
我们希望新线程能执行指定的代码，有以下几种方法：
</p>

<ol class="org-ol">
<li>从 <code>Thread</code> 派生一个自定义类，然后覆写 <code>run()</code> 方法；</li>
<li>创建 <code>Thread</code> 实例时，传入一个 <code>Runnable</code> 实例；</li>
<li>或用Java8引入的 lambda语法。</li>
</ol>

<blockquote>
<p>
小结：
</p>
<ul class="org-ul">
<li>Java用 <code>Thread</code> 对象表示一个线程，通过调用 <code>start()</code> 启动一个新线程；</li>
<li>一个线程对象只能调用一次 <code>start()</code> 方法；</li>
<li>线程的执行代码写在 <code>run()</code> 方法中；</li>
<li>线程调度由操作系统决定，程序本身无法决定调度顺序。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-orgac1864a" class="outline-3">
<h3 id="orgac1864a">线程的状态</h3>
<div class="outline-text-3" id="text-orgac1864a">
<p>
在Java程序中，一个线程对象只能调用一次 <code>start()</code> 方法启动新线程，并在新线程中执行 <code>run()</code> 方法。一旦 <code>run()</code> 方法执行完毕，线程就结束了。
</p>

<img
src="images/java-44.jpg"
width="300"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
如图所示，Java线程的状态有以下几种：
</p>

<ul class="org-ul">
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行 <code>run()</code> 方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行 <code>sleep()</code> 方法正在计时等待；</li>
<li>Terminated：线程已终止，因为 <code>run()</code> 方法执行完毕。</li>
</ul>

<p>
当线程启动后，它可以在 <code>Runnable、Blocked、Waiting</code> 和 <code>Timed Waiting</code> 这几个状态之间切换，直到最后变成 <code>Terminated</code> 状态，线程终止。
</p>

<p>
线程终止的原因有：
</p>

<ul class="org-ul">
<li>线程正常终止： <code>run()</code> 方法执行到return语句返回；</li>
<li>线程意外终止： <code>run()</code> 方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的 Thread实例调用 <code>stop()</code> 方法强制终止（强烈不推荐使用）。</li>
</ul>

<p>
通过对另一个线程对象调用 <code>join()</code> 方法可以等待其执行结束,对已经运行结束的线程调用 <code>join()</code> 方法会立刻返回。
</p>
</div>
</div>

<div id="outline-container-org0328e5b" class="outline-3">
<h3 id="org0328e5b">中断线程</h3>
<div class="outline-text-3" id="text-org0328e5b">
<p>
<code>main</code> 线程通过调用 <code>t.interrupt()</code> 方法中断 <code>t</code> 线程，但是要注意， <code>interrupt()</code> 方法仅仅向 <code>t</code> 线程发出了“中断请求”，至于 <code>t</code> 线程是否能立刻响应，要看具体代码。
</p>

<blockquote>
<p>
小结：
</p>

<p>
对目标线程调用 <code>interrupt()</code> 方法可以请求中断一个线程，目标线程通过检测 <code>isInterrupted()</code> 标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到 <code>InterruptedException</code> ；
</p>

<p>
目标线程检测到 <code>isInterrupted()</code> 为 <code>true</code> 或者捕获了 <code>InterruptedException</code> 都应该立刻结束自身线程；
</p>

<p>
通过标志位判断需要正确使用 <code>volatile</code> 关键字；=volatile= 关键字解决了共享变量在线程间的可见性问题。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org2cf9f0d" class="outline-3">
<h3 id="org2cf9f0d">守护进程</h3>
<div class="outline-text-3" id="text-org2cf9f0d">
<p>
守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
</p>

<p>
如何创建守护线程呢？方法和普通线程一样，只是在调用 <code>start()</code> 方法前，调用 <code>setDaemon(true)</code> 该线程标记为守护线程：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">MyThread</span><span style="color: #707183;">()</span>;
<span class="linenr">2: </span>t.setDaemon<span style="color: #707183;">(</span><span style="color: #a020f0;">true</span><span style="color: #707183;">)</span>;
<span class="linenr">3: </span>t.start<span style="color: #707183;">()</span>;
</pre>
</div>

<p>
在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。
</p>
</div>
</div>

<div id="outline-container-orgf03d9cb" class="outline-3">
<h3 id="orgf03d9cb">线程同步</h3>
<div class="outline-text-3" id="text-orgf03d9cb">
<p>
当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。
</p>

<p>
多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以 <b>原子方式</b> 执行：即某一个线程执行时，其他线程必须等待。
</p>

<blockquote>
<p>
<b>*原子操作是指不能被中断的一个或一系列操作。</b>
</p>
</blockquote>

<p>
如，对于语句 <code>n = n + 1;</code> ，看上去是一行语句，实际上对应了 3 条指令：
</p>

<pre class="example">
ILOAD
IADD
ISTORE
</pre>

<img
src="images/java-45.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✘
</p>

<img
src="images/java-46.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✔
</p>

<p>
通过加锁和解锁的操作，就能保证 3 条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。
</p>

<p>
即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 <span class="underline"><b>临界区</b> （Critical Section）</span> ，任何时候临界区最多只有一个线程能执行。
</p>

<p>
<b>可见，保证一段代码的原子性就是通过加锁和解锁实现的。</b>
</p>

<p>
Java程序使用 <code>synchronized</code> 关键字对一个对象进行加锁， <code>synchronized</code> 保证了代码块在任意时刻最多只有一个线程能执行。
</p>

<p>
如何使用 <code>synchronized</code> ：
</p>

<ul class="org-ul">
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用 <code>synchronized(lockObject) { ... }</code> 。</li>
</ul>

<p>
*因为 <code>synchronized</code> 代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以， <code>synchronized</code> 会降低程序的执行效率。
</p>

<p>
JVM 只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。因此，使用 <code>synchronized</code> 的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。
</p>

<blockquote>
<p>
小结：
</p>

<ul class="org-ul">
<li>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过 <code>synchronized</code> 同步；</li>
<li>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</li>
<li>注意加锁对象必须是同一个实例；</li>
<li>对 JVM 定义的单个原子操作不需要同步。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org0411443" class="outline-3">
<h3 id="org0411443">同步方法</h3>
<div class="outline-text-3" id="text-org0411443">
<p>
让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装，更好的方法是把 <code>synchronized</code> 逻辑封装起来。如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Counter</span> <span style="color: #707183;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">private</span> <span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">count</span> = 0;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr"> 5: </span>        <span style="color: #a020f0;">synchronized</span><span style="color: #909183;">(</span><span style="color: #a020f0;">this</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
<span class="linenr"> 6: </span>            count += n;
<span class="linenr"> 7: </span>        <span style="color: #909183;">}</span>
<span class="linenr"> 8: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">dec</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr">11: </span>        <span style="color: #a020f0;">synchronized</span><span style="color: #909183;">(</span><span style="color: #a020f0;">this</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
<span class="linenr">12: </span>            count -= n;
<span class="linenr">13: </span>        <span style="color: #909183;">}</span>
<span class="linenr">14: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">get</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
<span class="linenr">17: </span>        <span style="color: #a020f0;">return</span> count;
<span class="linenr">18: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">19: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
如此，线程调用 <code>add()</code> 、 <code>dec()</code> 方法时，它不必关心同步逻辑，因为 <code>synchronized</code> 代码块在 <code>add()</code> 、 <code>dec()</code> 方法内部。并且， <code>synchronized</code> 锁住的对象是 <code>this</code> ，即当前实例，这又使得创建多个 <code>Counter</code> 实例的时候，它们之间互不影响，可以并发执行。
</p>

<p>
如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。
</p>

<p>
*没有特殊说明时，一个类默认是非线程安全的。
</p>

<p>
当我们锁住的是 <code>this</code> 实例时，实际上可以用 <code>synchronized</code> 修饰这个方法。下面两种写法是等价的：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #707183;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">synchronized</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">this</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#38145;&#20303;this</span>
<span class="linenr"> 3: </span>        count += n;
<span class="linenr"> 4: </span>    <span style="color: #7388d6;">}</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#35299;&#38145;</span>
<span class="linenr"> 5: </span><span style="color: #707183;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#31561;&#20215;&#20110;</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">synchronized</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #707183;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#38145;&#20303;this</span>
<span class="linenr">10: </span>    count += n;
<span class="linenr">11: </span><span style="color: #707183;">}</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#35299;&#38145;</span>
</pre>
</div>

<p>
<b>因此，用 <code>synchronized</code> 修饰的方法就是同步方法，它表示整个方法都必须用 <code>this</code> 实例加锁。</b>
</p>
</div>
</div>
</div>

<div id="outline-container-orgbabdd5c" class="outline-2">
<h2 id="orgbabdd5c">JDBC 编程</h2>
<div class="outline-text-2" id="text-orgbabdd5c">
<p>
Java 为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity 。
</p>
</div>

<div id="outline-container-orgeb7736c" class="outline-3">
<h3 id="orgeb7736c">关系数据库</h3>
<div class="outline-text-3" id="text-orgeb7736c">
<p>
程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。
</p>

<p>
如何定义数据的存储格式就是一个大问题！
</p>

<p>
为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。
</p>

<hr>
<p>
<b>JDBC</b>
</p>

<p>
什么是 JDBC？JDBC 是 Java DataBase Connectivity 的缩写，它是 Java 程序访问数据库的标准接口。
</p>

<p>
使用 Java 程序访问数据库时，Java 代码并不直接通过 TCP 连接去访问数据库，而是通过 JDBC 接口来访问，而 JDBC 接口则通过 JDBC 驱动来实现真正对数据库的访问。
</p>

<blockquote>
<p>
*JDBC 接口是 Java 标准库自带的，所以可以直接编译。而具体的 JDBC 驱动是由数据库厂商提供的，不同厂商提供的 JDBC 驱动都是标准的。
</p>
</blockquote>

<p>
从代码来看，Java 标准库自带的 JDBC 接口其实就是定义了一组接口（在标准库 <code>java.sql</code> 中），而某个具体的 JDBC 驱动其实就是实现了这些接口的类：
</p>

<img
src="images/java-51.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
实际上，一个 MySQL 的 JDBC 的驱动就是一个 jar 包，它本身也是纯 Java 编写的。
</p>
</div>
</div>

<div id="outline-container-org73fe419" class="outline-3">
<h3 id="org73fe419">JDBC 操作</h3>
<div class="outline-text-3" id="text-org73fe419">
<p>
<b>1.JDBC连接</b>
</p>

<p>
使用 JDBC 时，我们先了解什么是 Connection ？
</p>

<p>
Connection 代表一个 JDBC 连接，它相当于 Java 程序到数据库的连接（通常是 TCP 连接）。打开一个 Connection 时，需要准备 URL、用户名和口令，才能成功连接到数据库。
</p>

<p>
URL 是由数据库厂商指定的格式，例如，MySQL 的 URL 是：
</p>

<pre class="example">
jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2

# 假设数据库运行在本机 localhost，
# 端口使用标准的3306，数据库名称是learnjdbc，那么URL如下：
jdbc:mysql://localhost:3306/learnjdbc?useSSL=false&amp;characterEncoding=utf8
# 后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码
</pre>

<p>
要获取数据库连接，使用如下代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">JDBC&#36830;&#25509;&#30340;URL, &#19981;&#21516;&#25968;&#25454;&#24211;&#26377;&#19981;&#21516;&#30340;&#26684;&#24335;:</span>
<span class="linenr"> 2: </span><span style="color: #a020f0;">String</span> <span style="color: SystemWindowText;">JDBC_URL</span> = <span style="color: #8b2252;">"jdbc:mysql://localhost:3306/test"</span>;
<span class="linenr"> 3: </span><span style="color: #a020f0;">String</span> <span style="color: SystemWindowText;">JDBC_USER</span> = <span style="color: #8b2252;">"root"</span>;
<span class="linenr"> 4: </span><span style="color: #a020f0;">String</span> <span style="color: SystemWindowText;">JDBC_PASSWORD</span> = <span style="color: #8b2252;">"password"</span>;
<span class="linenr"> 5: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#33719;&#21462;&#36830;&#25509;&#65306;</span>
<span class="linenr"> 6: </span><span style="color: #a020f0;">Connection</span> <span style="color: SystemWindowText;">conn</span> = DriverManager.getConnection<span style="color: #707183;">(</span>JDBC_URL, JDBC_USER, JDBC_PASSWORD<span style="color: #707183;">)</span>;
<span class="linenr"> 7: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">TODO: &#35775;&#38382;&#25968;&#25454;&#24211;...</span>
<span class="linenr"> 8: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">...</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#20851;&#38381;&#36830;&#25509;</span>
<span class="linenr">11: </span>conn.close<span style="color: #707183;">()</span>;
</pre>
</div>

<p>
核心代码是 <code>DriverManager</code> 提供的静态方法 <code>getConnection()</code> 。 <code>DriverManager</code> 会自动扫描 classpath，找到所有的 JDBC 驱动，然后根据我们传入的 <code>URL</code> 自动挑选一个合适的驱动。
</p>

<hr>
<p>
<b>2.JDBC 查询</b>
</p>

<p>
通过 <code>Connection</code> 提供的 <code>createStatement()</code> 方法创建一个 <code>Statement</code> 对象，用于执行一个查询。
</p>

<p>
使用 <code>Statement</code> 拼字符串非常容易引发 SQL 注入的问题，这是因为 SQL 参数往往是从方法参数传入的。
</p>

<p>
使用 <code>PreparedStatement</code> 可以完全避免SQL注入的问题，且更快、更安全。
</p>

<blockquote>
<p>
<b>使用 Java 对数据库进行操作时，必须使用 <code>PreparedStatement</code> ，严禁任何通过参数拼字符串的代码！</b>
</p>
</blockquote>

<p>
查询结果总是 <code>ResultSet</code> ，即使使用聚合查询也不例外。
</p>

<hr>
<p>
后续插入、更新、删除，本质上也是用 <code>PreparedStatement</code> 执行一条 SQL 语句，不过最后执行的不是 <code>executeQuery()</code> ，而是 <code>executeUpdate()</code> 。
</p>
</div>
</div>

<div id="outline-container-org462f421" class="outline-3">
<h3 id="org462f421">JDBC 事务</h3>
<div class="outline-text-3" id="text-org462f421">
<p>
数据库事务（Transaction）是由若干个 SQL 语句构成的一个操作序列，数据库系统保证在一个事务中的所有 SQL 要么全部执行成功，要么全部不执行。
</p>

<p>
对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。
</p>

<p>
JDBC 提供了事务的支持，使用 Connection 可以开启、提交或回滚事务。要在 JDBC 中执行事务，本质上就是如何把多条 SQL 包裹在一个数据库事务中执行。
</p>
</div>
</div>

<div id="outline-container-orgb7736d1" class="outline-3">
<h3 id="orgb7736d1">JDBC Batch</h3>
<div class="outline-text-3" id="text-orgb7736d1">
<p>
使用 JDBC 操作数据库的时候，经常会执行一些批量操作。
</p>

<p>
通过一个循环来执行每个 <code>PreparedStatement</code> 虽然可行，但是性能很低。SQL 数据库对 SQL 语句相同，但 <b>只有参数不同的若干语句</b> 可以作为 batch 执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个 SQL。
</p>

<p>
使用 JDBC 的 batch 操作会大大提高执行效率，对内容相同，参数不同的 SQL，要优先考虑 batch 操作。
</p>
</div>
</div>

<div id="outline-container-org34af4ce" class="outline-3">
<h3 id="org34af4ce">JDBC 连接池</h3>
<div class="outline-text-3" id="text-org34af4ce">
<p>
为了避免频繁地创建和销毁 JDBC 连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。
</p>

<p>
JDBC 连接池有一个标准的接口 <code>javax.sql.DataSource</code> ，注意这个类位于 Java 标准库中，但仅仅是接口。要使用 JDBC 连接池，我们必须选择一个 JDBC 连接池的实现。
</p>

<p>
目前使用最广泛的是 HikariCP。
</p>

<p>
连接池内部维护了若干个 <code>Connection</code> 实例，如果调用 <code>ds.getConnection()</code> ，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对 <code>Connection</code> 调用 <code>close()</code> ，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的 SQL 语句。
</p>
</div>
</div>
</div>

<div id="outline-container-org90abfd7" class="outline-2">
<h2 id="org90abfd7">Web 开发</h2>
<div class="outline-text-2" id="text-org90abfd7">
</div>
<div id="outline-container-orgb441b15" class="outline-3">
<h3 id="orgb441b15">JavaEE</h3>
<div class="outline-text-3" id="text-orgb441b15">
<p>
JavaEE 是完全基于JavaSE，只是多了一大堆服务器相关的库以及 API 接口。所有的 JavaEE 程序，仍然是运行在标准的 JavaSE 的虚拟机上的。
</p>

<p>
JavaEE 并不是一个软件产品，它更多的是一种软件架构和设计思想。我们可以把 JavaEE 看作是在 JavaSE 的基础上，开发的一系列基于服务器的组件、API标准和通用架构。
</p>

<img
src="images/java-48.jpg"
width="120"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
<b>JavaEE 最核心的组件就是基于 Servlet标准的Web服务器</b> （如 Tomcat），开发者编写的应用程序是基于 Servlet API 并运行在 Web服务器内部的。
</p>

<p>
目前流行的基于 Spring 的轻量级 JavaEE 开发架构，使用最广泛的是 Servlet 和 JMS ，以及一系列开源组件。
</p>
</div>
</div>

<div id="outline-container-orgece8e66" class="outline-3">
<h3 id="orgece8e66">Web 基础</h3>
<div class="outline-text-3" id="text-orgece8e66">
<p>
<b>HTTP 协议（需要单独深入一下）</b>
</p>

<p>
HTTP 协议是一个基于 TCP 协议之上的请求-响应协议。
</p>

<p>
通常浏览器获取的 <b>第一个资源</b> 是 HTML 网页，在网页中，如果嵌入了 JavaScript、 CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。
</p>

<p>
如何编写 HTTP Server ？
</p>

<p>
一个 HTTP Server 本质上是一个 TCP 服务器，我们可以用 TCP 编程的多线程来实现一个服务器端框架。
</p>
</div>
</div>

<div id="outline-container-orgb8fc0b3" class="outline-3">
<h3 id="orgb8fc0b3">Servlet</h3>
<div class="outline-text-3" id="text-orgb8fc0b3">
<p>
我们看到，编写 HTTP 服务器其实是非常简单的，只需要先编写基于多线程的 TCP 服务，然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可。
</p>

<p>
但是，要编写一个完善的HTTP服务器，需要考虑好多方面，经过长期测试才能稳定运行。
</p>

<p>
因此，在 JavaEE 平台上，处理 TCP 连接，解析 HTTP 协议这些底层工作统统扔给现成的 Web 服务器去做，我们只需要把自己的应用程序跑在 Web 服务器上。
</p>

<p>
为了实现这一目的， <b>JavaEE 提供了 Servlet API</b> ， <b>Web 服务器实现 Servlet API 接口</b> ，实现底层功能。 <b>我们使用 Servlet API 编写自己的 Servlet</b> 来处理 HTTP 请求。
</p>

<p>
一个 Servlet 总是继承自 <code>HttpServlet</code> ，然后覆写 <code>doGet()</code> 或 <code>doPost()</code> 方法。它们接收 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 两个对象做为参数，分别代表 HTTP 请求和响应。
</p>

<p>
我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 <code>PrintWriter</code> ，写入响应即可。
</p>

<p>
<b>Servlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。</b>
</p>

<p>
看一下伪示例的 <code>pom.xml</code> 文件如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project...</span>&gt;
<span class="linenr"> 2: </span>    ...
<span class="linenr"> 3: </span>    &lt;<span style="color: SystemWindowText;">packaging</span>&gt;war&lt;/<span style="color: SystemWindowText;">packaging</span>&gt;
<span class="linenr"> 4: </span>    ...
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    &lt;<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr"> 7: </span>        &lt;<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 8: </span>            &lt;<span style="color: SystemWindowText;">groupId</span>&gt;javax.servlet&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr"> 9: </span>            &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;javax.servlet-api&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr">10: </span>            &lt;<span style="color: SystemWindowText;">version</span>&gt;4.0.0&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr">11: </span>            &lt;<span style="color: SystemWindowText;">scope</span>&gt;provided&lt;/<span style="color: SystemWindowText;">scope</span>&gt;
<span class="linenr">12: </span>        &lt;/<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr">13: </span>    &lt;/<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr">14: </span>    ...
<span class="linenr">15: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<p>
注意 <code>&lt;packaging&gt;war&lt;/packaging&gt;</code> ，打包的类型不是 <code>jar</code> ，而是 <code>war</code> ； <code>&lt;scope&gt;</code> 指定为 <code>provided</code> ，表示编译时使用，但不会打包到 <code>.war</code> 文件中，因为运行期 Web 服务器本身已经提供了 Servlet API 相关的 jar 包。
</p>

<hr>
<p>
<b>web.xml</b>
</p>

<p>
我们还需要在工程目录下创建一个 <code>web.xml</code> 描述文件，放到 <code>src/main/webapp/WEB-INF</code> 目录下（固定目录结构，不要修改路径，注意大小写）。如：
</p>

<img
src="images/java-49.jpg"
width="430"
height=""
style=""
title=""
/>

<p>
运行 Maven 命令 <code>mvn clean package</code> ，在 <code>target</code> 目录下得到一个 <code>hello.war</code> 文件，这个文件就是我们编译打包后的 Web 应用程序。
</p>

<hr>
<p>
<b>我们应该如何运行这个 <code>war</code> 文件？</b>
</p>

<p>
普通的 Java 程序是通过启动 JVM，然后执行 <code>main()</code> 方法开始运行。 但是 Web 应用程序有所不同， <b>我们无法直接运行 <code>war</code> 文件</b> ，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 <code>HelloServlet</code> ，这样就可以让 <code>HelloServlet</code> 处理浏览器发送的请求。
</p>

<p>
因此，我们首先要找一个支持 Servlet API 的 Web 服务器。常用的服务器有：
</p>

<ul class="org-ul">
<li>Tomcat：由Apache开发的开源免费服务器；</li>
<li>Jetty：由Eclipse开发的开源免费服务器；</li>
<li>GlassFish：一个开源的全功能JavaEE服务器。</li>
</ul>

<p>
无论使用哪个服务器，只要它支持 Servlet API 4.0（因为我们引入的Servlet版本是4.0），我们的 war 包都可以在上面运行。
</p>

<blockquote>
<p>
实际上，类似 Tomcat 这样的服务器也是 Java 编写的，启动 Tomcat 服务器实际上是启动 Java 虚拟机，执行 Tomcat 的 <code>main()</code> 方法，然后由 Tomcat 负责加载我们的 <code>.war</code> 文件，并创建一个 <code>HelloServlet</code> 实例，最后以多线程的模式来处理 HTTP 请求。
</p>
</blockquote>

<p>
因为我们编写的 Servlet 并不是直接运行，而是由 Web 服务器加载后创建实例运行，所以，类似 Tomcat 这样的 Web 服务器也称为 <span class="underline">Servlet 容器</span> 。
</p>

<p>
在 Servlet 容器中运行的 Servlet 具有如下特点：
</p>

<ul class="org-ul">
<li>无法在代码中直接通过 <code>new</code> 创建 <code>Servlet</code> 实例，必须由 Servlet 容器自动创建 Servlet 实例；</li>
<li>Servlet 容器只会给每个 Servlet 类创建唯一实例；</li>
<li>Servlet 容器会使用多线程执行 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li>……</li>
<li>在 Servlet 中定义的实例变量会被多个线程同时访问，要注意线程安全；</li>
<li><code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 实例是由 Servlet 容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；</li>
<li>在 <code>doGet()</code> 或 <code>doPost()</code> 方法中，如果使用了 ThreadLocal，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为 Servlet 容器很可能用线程池实现线程复用。</li>
</ul>

<p>
因此，正确编写 Servlet，要清晰理解 Java 的多线程模型，需要同步访问的必须同步。
</p>
</div>
</div>

<div id="outline-container-org63879d3" class="outline-3">
<h3 id="org63879d3">Servlet 开发</h3>
<div class="outline-text-3" id="text-org63879d3">
<p>
一个完整的 Web 应用程序的开发流程如下：
</p>

<ul class="org-ul">
<li>编写 Servlet；</li>
<li>打包为 war 文件；</li>
<li>复制到 Tomcat 的 webapps 目录下；</li>
<li>启动 Tomcat。</li>
</ul>

<p>
许多初学者经常卡在如何在 IDE 中启动 Tomcat 并加载 webapp，更不要说断点调试了……
</p>

<p>
……
</p>

<p>
因为 Tomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：
</p>

<ul class="org-ul">
<li>启动 JVM 并执行 Tomcat 的 <code>main()</code> 方法；</li>
<li>加载 war 并初始化 Servlet；</li>
<li>正常服务。</li>
</ul>

<p>
启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 <code>main()</code> 方法，我们完全可以 <b>把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 <code>main()</code> 方法</b> ，先启动 Tomcat，然后让它加载我们的 webapp 就行。
</p>

<blockquote>
<p>
现在好了，SpringBoot 支持在 <code>main()</code> 方法中一行代码直接启动 Tomcat 。
</p>
</blockquote>

<p>
*开发 Servlet 时，推荐使用 <code>main()</code> 方法启动嵌入式 Tomcat 服务器并加载当前工程的 webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。
</p>
</div>
</div>
</div>

<div id="outline-container-org6cfe720" class="outline-2">
<h2 id="org6cfe720">Spring 开发</h2>
<div class="outline-text-2" id="text-org6cfe720">
</div>
<div id="outline-container-orga557055" class="outline-3">
<h3 id="orga557055">AOP 本质</h3>
<div class="outline-text-3" id="text-orga557055">
<p>
<b>AOP 的本质就是一个动态代理，</b> 让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。
</p>

<blockquote>
<p>
需要特别指出的是，AOP 对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC 的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用 AOP 实现日志，我们只能输出固定格式的日志，因此，使用 AOP 时，必须适合特定的场景。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgc20326a" class="outline-3">
<h3 id="orgc20326a">装配 AOP</h3>
<div class="outline-text-3" id="text-orgc20326a">
<p>
AOP 本质上只是一种代理模式的实现方式，在 Spring 的容器中实现 AOP 特别方便。
</p>

<blockquote>
<p>
Spring 对接口类型使用 JDK 动态代理，对普通类使用 CGLIB 创建子类。如果一个 Bean 的 class 是 <code>final</code> ，Spring 将无法为其创建子类。
</p>
</blockquote>

<p>
虽然 Spring 容器内部实现 AOP 的逻辑比较复杂（需要使用 AspectJ 解析注解，并通过 CGLIB 实现代理类），但我们使用 AOP 非常简单，一共需要三步：
</p>

<ul class="org-ul">
<li>定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法；</li>
<li>标记 <code>@Component</code> 和 <code>@Aspect</code> ；</li>
<li>在 <code>@Configuration</code> 类上标注 <code>@EnableAspectJAutoProxy</code> 。</li>
</ul>

<p>
使用注解实现 AOP 需要先定义注解，然后使用 <code>@Around("@annotation(name)")</code> 实现装配。
</p>

<p>
使用注解既简单，又能明确标识 AOP 装配，是使用 AOP 推荐的方式。
</p>
</div>
</div>

<div id="outline-container-orgce4866b" class="outline-3">
<h3 id="orgce4866b">AOP 避坑指南</h3>
<div class="outline-text-3" id="text-orgce4866b">
<p>
无论是使用 AspectJ 语法，还是配合 Annotation ，使用 AOP ，实际上就是让 Spring 自动为我们创建一个 Proxy ，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑。因此， <b>AOP 本质上就是一个代理模式</b> 。
</p>

<p>
因为 Spring 使用了 CGLIB 来实现运行期动态创建 Proxy ，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。
</p>

<p>
……
</p>

<essay>
使用的过程中，慢慢埋坑吧……
</essay>
</div>
</div>

<div id="outline-container-orgb597d13" class="outline-3">
<h3 id="orgb597d13">访问数据库</h3>
<div class="outline-text-3" id="text-orgb597d13">
<p>
使用 JDBC 虽然简单，但代码比较繁琐。Spring 为了简化数据库访问，主要做了以下几点工作：
</p>

<ul class="org-ul">
<li>提供了简化的访问 JDBC 的模板类，不必手动释放资源；</li>
<li>提供了一个统一的 DAO 类以实现 Data Access Object 模式；</li>
<li>把 <code>SQLException</code> 封装为 <code>DataAccessException</code> ，这个异常是一个 <code>RuntimeException</code> ，并且让我们能区分SQL异常的原因，例如， <code>DuplicateKeyException</code> 表示违反了一个唯一约束；</li>
<li>能方便地集成 Hibernate、JPA 和 MyBatis 这些数据库访问框架。</li>
</ul>
</div>
</div>

<div id="outline-container-org04c4606" class="outline-3">
<h3 id="org04c4606"><span class="todo TODO">TODO</span> 使用 JDBC</h3>
<div class="outline-text-3" id="text-org04c4606">
<p>
……
</p>

<p>
小结：
</p>
<ul class="org-ul">
<li>Spring 提供了 <code>JdbcTemplate</code> 来简化 JDBC 操作；</li>
<li>使用 <code>JdbcTemplate</code> 时，根据需要优先选择高级方法；</li>
<li>任何 JDBC 操作都可以使用保底的 <code>execute(ConnectionCallback)</code> 方法。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-04-04 Sun 17:23</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-04-13 Tue 17:43</p>
<p class="validation"><a href="http://beian.miit.gov.cn/">豫ICP备19025929号</a></p>
</div>
</body>
</html>
