<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-04-06 Tue 17:52 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java Inbox</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="themes/assets/rose-red.png" type="image/x-icon" />
           <link rel="stylesheet" href="themes/style.css" type="text/css"  />
           <script type="module" src="themes/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">Java Inbox</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge5786f1">面向对象</a>
<ul>
<li><a href="#org414b509">模块</a></li>
</ul>
</li>
<li><a href="#org2239133">Maven</a>
<ul>
<li><a href="#org28e972d">Maven 项目结构</a></li>
</ul>
</li>
<li><a href="#orgfa55330">多线程</a>
<ul>
<li><a href="#org55ba8d0">线程和进程</a></li>
<li><a href="#org0bf1885">创建新线程</a></li>
<li><a href="#org9e31a52">线程的状态</a></li>
<li><a href="#org46885ce">中断线程</a></li>
<li><a href="#org7fff4b0">守护进程</a></li>
<li><a href="#org35c6f95">线程同步</a></li>
<li><a href="#org1dd1fff">同步方法</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
→ 摘录自廖雪峰老师的 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a>
</p>

<div id="outline-container-orge5786f1" class="outline-2">
<h2 id="orge5786f1">面向对象</h2>
<div class="outline-text-2" id="text-orge5786f1">
</div>
<div id="outline-container-org414b509" class="outline-3">
<h3 id="org414b509">模块</h3>
<div class="outline-text-3" id="text-org414b509">
<p>
<b>为什么需要模块？</b>
</p>

<p>
<code>.class</code> 文件是 JVM 看到的最小可执行文件，jar 是用于存放 class 的容器，它并不关心 class 之间的依赖。
</p>

<p>
从Java 9开始引入了自带“依赖关系”的 class 容器 &#x2013; <b>模块</b> 。
</p>

<p>
<b>如何编写模块呢？</b>
</p>

<img
src="images/java-42.png"
width="660"
height=""
style=""
title=""
/>

<p>
仅仅在 <code>src</code> 目录下多了一个 <code>module-info.java</code> 这个文件，这就是模块的描述文件。如：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">module</span> hello.<span style="color: SystemWindowText;">world</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">base</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21487;&#19981;&#20889;&#65292;&#20219;&#20309;&#27169;&#22359;&#37117;&#20250;&#33258;&#21160;&#24341;&#20837;java.base</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">xml</span>;
<span class="linenr">4: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
*当我们使用模块声明了依赖关系后，才能使用引入的模块。
</p>

<p>
<b>模块有什么用？</b>
</p>

<p>
我们可以用它来打包 JRE ！
</p>

<p>
模块进一步隔离了代码的访问权限，只有它声明的导出的包，外部代码才被允许访问。
</p>
</div>
</div>
</div>

<div id="outline-container-org2239133" class="outline-2">
<h2 id="org2239133">Maven</h2>
<div class="outline-text-2" id="text-org2239133">
<p>
Maven 是一个 Java 项目管理和构建工具，它可以定义项目结构、项目依赖，并且用统一的方式进行自动化构建。
</p>
</div>

<div id="outline-container-org28e972d" class="outline-3">
<h3 id="org28e972d">Maven 项目结构</h3>
</div>
</div>

<div id="outline-container-orgfa55330" class="outline-2">
<h2 id="orgfa55330">多线程</h2>
<div class="outline-text-2" id="text-orgfa55330">
</div>
<div id="outline-container-org55ba8d0" class="outline-3">
<h3 id="org55ba8d0">线程和进程</h3>
<div class="outline-text-3" id="text-org55ba8d0">
<p>
进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。
</p>

<img
src="images/java-43.jpg"
width="660"
height=""
style=""
title=""
/>

<p>
操作系统调度的最小任务单位其实不是进程，而是线程。
</p>

<p>
相对进程来说，创建线程开销小、通信快（线程间通信就是读写同一个变量）。多进程的好处在于稳定性好，一个进程崩溃不会影响其他进程。
</p>

<p>
Java 语言内置了多线程的支持：一个 Java 程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行 <code>main()</code> 方法，在 <code>main()</code> 方法内部，我们又可以启动多个线程。此外，JVM 还有负责垃圾回收的其他工作线程等。
</p>

<p>
因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。
</p>

<p>
Java多线程编程的特点又在于：
</p>

<ul class="org-ul">
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
</div>
</div>

<div id="outline-container-org0bf1885" class="outline-3">
<h3 id="org0bf1885">创建新线程</h3>
<div class="outline-text-3" id="text-org0bf1885">
<p>
要创建一个新线程非常容易，我们需要实例化一个 <code>Thread</code> 实例，然后调用它的 <code>start()</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Main</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">main</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">String</span><span style="color: #909183;">[]</span> <span style="color: SystemWindowText;">args</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">Thread</span><span style="color: #909183;">()</span>;
<span class="linenr">4: </span>        t.start<span style="color: #909183;">()</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21551;&#21160;&#26032;&#32447;&#31243;</span>
<span class="linenr">5: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">6: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
但是这个线程启动后实际上什么也不做就立刻结束了。
</p>

<p>
我们希望新线程能执行指定的代码，有以下几种方法：
</p>

<ol class="org-ol">
<li>从 <code>Thread</code> 派生一个自定义类，然后覆写 <code>run()</code> 方法；</li>
<li>创建 <code>Thread</code> 实例时，传入一个 <code>Runnable</code> 实例；</li>
<li>或用Java8引入的 lambda语法。</li>
</ol>

<blockquote>
<p>
小结：
</p>
<ul class="org-ul">
<li>Java用 <code>Thread</code> 对象表示一个线程，通过调用 <code>start()</code> 启动一个新线程；</li>
<li>一个线程对象只能调用一次 <code>start()</code> 方法；</li>
<li>线程的执行代码写在 <code>run()</code> 方法中；</li>
<li>线程调度由操作系统决定，程序本身无法决定调度顺序。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org9e31a52" class="outline-3">
<h3 id="org9e31a52">线程的状态</h3>
<div class="outline-text-3" id="text-org9e31a52">
<p>
在Java程序中，一个线程对象只能调用一次 <code>start()</code> 方法启动新线程，并在新线程中执行 <code>run()</code> 方法。一旦 <code>run()</code> 方法执行完毕，线程就结束了。
</p>

<img
src="images/java-44.jpg"
width="300"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
如图所示，Java线程的状态有以下几种：
</p>

<ul class="org-ul">
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行 <code>run()</code> 方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行 <code>sleep()</code> 方法正在计时等待；</li>
<li>Terminated：线程已终止，因为 <code>run()</code> 方法执行完毕。</li>
</ul>

<p>
当线程启动后，它可以在 <code>Runnable、Blocked、Waiting</code> 和 <code>Timed Waiting</code> 这几个状态之间切换，直到最后变成 <code>Terminated</code> 状态，线程终止。
</p>

<p>
线程终止的原因有：
</p>

<ul class="org-ul">
<li>线程正常终止： <code>run()</code> 方法执行到return语句返回；</li>
<li>线程意外终止： <code>run()</code> 方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的 Thread实例调用 <code>stop()</code> 方法强制终止（强烈不推荐使用）。</li>
</ul>

<p>
通过对另一个线程对象调用 <code>join()</code> 方法可以等待其执行结束,对已经运行结束的线程调用 <code>join()</code> 方法会立刻返回。
</p>
</div>
</div>

<div id="outline-container-org46885ce" class="outline-3">
<h3 id="org46885ce">中断线程</h3>
<div class="outline-text-3" id="text-org46885ce">
<p>
<code>main</code> 线程通过调用 <code>t.interrupt()</code> 方法中断 <code>t</code> 线程，但是要注意， <code>interrupt()</code> 方法仅仅向 <code>t</code> 线程发出了“中断请求”，至于 <code>t</code> 线程是否能立刻响应，要看具体代码。
</p>

<blockquote>
<p>
小结：
</p>

<p>
对目标线程调用 <code>interrupt()</code> 方法可以请求中断一个线程，目标线程通过检测 <code>isInterrupted()</code> 标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到 <code>InterruptedException</code> ；
</p>

<p>
目标线程检测到 <code>isInterrupted()</code> 为 <code>true</code> 或者捕获了 <code>InterruptedException</code> 都应该立刻结束自身线程；
</p>

<p>
通过标志位判断需要正确使用 <code>volatile</code> 关键字；=volatile= 关键字解决了共享变量在线程间的可见性问题。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org7fff4b0" class="outline-3">
<h3 id="org7fff4b0">守护进程</h3>
<div class="outline-text-3" id="text-org7fff4b0">
<p>
守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
</p>

<p>
如何创建守护线程呢？方法和普通线程一样，只是在调用 <code>start()</code> 方法前，调用 <code>setDaemon(true)</code> 该线程标记为守护线程：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">MyThread</span><span style="color: #707183;">()</span>;
<span class="linenr">2: </span>t.setDaemon<span style="color: #707183;">(</span><span style="color: #a020f0;">true</span><span style="color: #707183;">)</span>;
<span class="linenr">3: </span>t.start<span style="color: #707183;">()</span>;
</pre>
</div>

<p>
在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。
</p>
</div>
</div>

<div id="outline-container-org35c6f95" class="outline-3">
<h3 id="org35c6f95">线程同步</h3>
<div class="outline-text-3" id="text-org35c6f95">
<p>
当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。
</p>

<p>
多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以 <b>原子方式</b> 执行：即某一个线程执行时，其他线程必须等待。
</p>

<blockquote>
<p>
<b>*原子操作是指不能被中断的一个或一系列操作。</b>
</p>
</blockquote>

<p>
如，对于语句 <code>n = n + 1;</code> ，看上去是一行语句，实际上对应了 3 条指令：
</p>

<pre class="example">
ILOAD
IADD
ISTORE
</pre>

<img
src="images/java-45.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✘
</p>

<img
src="images/java-46.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✔
</p>

<p>
通过加锁和解锁的操作，就能保证 3 条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。
</p>

<p>
即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 <span class="underline"><b>临界区</b> （Critical Section）</span> ，任何时候临界区最多只有一个线程能执行。
</p>

<p>
<b>可见，保证一段代码的原子性就是通过加锁和解锁实现的。</b>
</p>

<p>
Java程序使用 <code>synchronized</code> 关键字对一个对象进行加锁， <code>synchronized</code> 保证了代码块在任意时刻最多只有一个线程能执行。
</p>

<p>
如何使用 <code>synchronized</code> ：
</p>

<ul class="org-ul">
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用 <code>synchronized(lockObject) { ... }</code> 。</li>
</ul>

<p>
*因为 <code>synchronized</code> 代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以， <code>synchronized</code> 会降低程序的执行效率。
</p>

<p>
JVM 只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。因此，使用 <code>synchronized</code> 的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。
</p>

<blockquote>
<p>
小结：
</p>

<ul class="org-ul">
<li>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过 <code>synchronized</code> 同步；</li>
<li>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</li>
<li>注意加锁对象必须是同一个实例；</li>
<li>对 JVM 定义的单个原子操作不需要同步。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org1dd1fff" class="outline-3">
<h3 id="org1dd1fff">同步方法</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-04-04 Sun 17:23</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-04-06 Tue 17:52</p>
<p class="validation"><a href="http://beian.miit.gov.cn/">豫ICP备19025929号</a></p>
</div>
</body>
</html>
