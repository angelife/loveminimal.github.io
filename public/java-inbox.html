<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-04-09 Fri 17:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java Inbox</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="themes/assets/rose-red.png" type="image/x-icon" />
           <link rel="stylesheet" href="themes/style.css" type="text/css"  />
           <script type="module" src="themes/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">Java Inbox</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge5786f1">面向对象</a>
<ul>
<li><a href="#org414b509">模块</a></li>
</ul>
</li>
<li><a href="#org2239133">Maven</a>
<ul>
<li><a href="#org74cde4b">为什么需要 Maven</a></li>
<li><a href="#orgd84c6e8">Maven 项目结构</a></li>
<li><a href="#org9c48f29">项目描述文件</a></li>
<li><a href="#org689d86c">依赖管理</a></li>
<li><a href="#orgd43dd8a">Maven 镜像</a></li>
<li><a href="#orge46948e"><span class="todo TODO">TODO</span> 构建流程</a></li>
</ul>
</li>
<li><a href="#orgfa55330"><span class="todo TODO">TODO</span> 多线程</a>
<ul>
<li><a href="#org55ba8d0">线程和进程</a></li>
<li><a href="#org0bf1885">创建新线程</a></li>
<li><a href="#org9e31a52">线程的状态</a></li>
<li><a href="#org46885ce">中断线程</a></li>
<li><a href="#org7fff4b0">守护进程</a></li>
<li><a href="#org35c6f95">线程同步</a></li>
<li><a href="#org1dd1fff">同步方法</a></li>
</ul>
</li>
<li><a href="#orgbf641b8">Web 开发</a>
<ul>
<li><a href="#org9be0100">JavaEE</a></li>
<li><a href="#org5a99c74">Web 基础</a></li>
<li><a href="#org1eda366">Servlet</a></li>
<li><a href="#orgab0faa8">Servlet 开发</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
→ 摘录自廖雪峰老师的 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a>
</p>

<div id="outline-container-orge5786f1" class="outline-2">
<h2 id="orge5786f1">面向对象</h2>
<div class="outline-text-2" id="text-orge5786f1">
</div>
<div id="outline-container-org414b509" class="outline-3">
<h3 id="org414b509">模块</h3>
<div class="outline-text-3" id="text-org414b509">
<p>
<b>为什么需要模块？</b>
</p>

<p>
<code>.class</code> 文件是 JVM 看到的最小可执行文件，jar 是用于存放 class 的容器，它并不关心 class 之间的依赖。
</p>

<p>
从Java 9开始引入了自带“依赖关系”的 class 容器 &#x2013; <b>模块</b> 。
</p>

<p>
<b>如何编写模块呢？</b>
</p>

<img
src="images/java-42.png"
width="660"
height=""
style=""
title=""
/>

<p>
仅仅在 <code>src</code> 目录下多了一个 <code>module-info.java</code> 这个文件，这就是模块的描述文件。如：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">module</span> hello.<span style="color: SystemWindowText;">world</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">base</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21487;&#19981;&#20889;&#65292;&#20219;&#20309;&#27169;&#22359;&#37117;&#20250;&#33258;&#21160;&#24341;&#20837;java.base</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">requires</span> java.<span style="color: SystemWindowText;">xml</span>;
<span class="linenr">4: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
*当我们使用模块声明了依赖关系后，才能使用引入的模块。
</p>

<p>
<b>模块有什么用？</b>
</p>

<p>
我们可以用它来打包 JRE ！
</p>

<p>
模块进一步隔离了代码的访问权限，只有它声明的导出的包，外部代码才被允许访问。
</p>
</div>
</div>
</div>

<div id="outline-container-org2239133" class="outline-2">
<h2 id="org2239133">Maven</h2>
<div class="outline-text-2" id="text-org2239133">
<p>
Maven 是一个 Java 项目管理和构建工具，它可以定义 <span class="underline">项目结构</span> 、 <span class="underline">项目依赖</span> ，并且用统一的方式进行 <span class="underline">自动化构建</span> （编译、测试、打包、发布……）。
</p>

<essay>
在标准化这件事上，真是你好、我好、大家好！
</essay>
</div>

<div id="outline-container-org74cde4b" class="outline-3">
<h3 id="org74cde4b">为什么需要 Maven</h3>
<div class="outline-text-3" id="text-org74cde4b">
<p>
一个 Java 项目需要什么？
</p>

<p>
首先，确定 <b>目录结构</b> 。
</p>

<p>
其次，我们需要确定 <b>引入哪些依赖包</b> ，并把它们加入 classpath 。
</p>

<p>
此外，还需要配置环境，例如 JDK 的版本，编译打包的流程，当前代码的版本号。
</p>

<p>
如果你不使用 IDE ，那么我们就不得不使用命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。
</p>

<p>
这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。
</p>

<essay>
哎，多项目，不标准化，真的是一言难尽……
</essay>
</div>
</div>

<div id="outline-container-orgd84c6e8" class="outline-3">
<h3 id="orgd84c6e8">Maven 项目结构</h3>
<div class="outline-text-3" id="text-orgd84c6e8">
<img
src="images/java-47.jpg"
width="200"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
项目的根目录 <code>a-maven-project</code> 是项目名，它有一个项目描述文件 <code>pom.xml</code> ，存放 Java 源码的目录是 <code>src/main/java</code> ，存放资源文件的目录是 <code>src/main/resources</code> ，存放测试源码的目录是 <code>src/test/java</code> ，存放资源的目录是 <code>src/test/resources</code> ，最后，所有编译、打包生成的文件都放在 <code>target</code> 目录里。
</p>

<p>
所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven 就可以正常使用。
</p>

<essay>
确定的目录结构，对于 Maven 来说也是必须的，因为实现 Maven 这个工具本身也需要按照相对确定的路径来扫描所要使用的文件。
</essay>
</div>
</div>

<div id="outline-container-org9c48f29" class="outline-3">
<h3 id="org9c48f29">项目描述文件</h3>
<div class="outline-text-3" id="text-org9c48f29">
<p>
POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个 XML 文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。
</p>

<p>
执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。
</p>

<p>
<b>所有 POM 文件都需要 <code>project</code> 元素和三个必需字段： <code>groupId，artifactId，version</code> 。</b>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project</span> <span style="color: #a020f0;">xmlns</span> = <span style="color: #8b2252;">"http://maven.apache.org/POM/4.0.0"</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">xmlns</span>:<span style="color: SystemWindowText;">xsi</span> = <span style="color: #8b2252;">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="linenr"> 3: </span>    <span style="color: #a020f0;">xsi</span>:<span style="color: SystemWindowText;">schemaLocation</span> = <span style="color: #8b2252;">"http://maven.apache.org/POM/4.0.0</span>
<span class="linenr"> 4: </span><span style="color: #8b2252;">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#27169;&#22411;&#29256;&#26412; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr"> 7: </span>    &lt;<span style="color: SystemWindowText;">modelVersion</span>&gt;4.0.0&lt;/<span style="color: SystemWindowText;">modelVersion</span>&gt;
<span class="linenr"> 8: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#20844;&#21496;&#25110;&#32773;&#32452;&#32455;&#30340;&#21807;&#19968;&#26631;&#24535;&#65292;&#24182;&#19988;&#37197;&#32622;&#26102;&#29983;&#25104;&#30340;&#36335;&#24452;&#20063;&#26159;&#30001;&#27492;&#29983;&#25104;&#65292;</span>
<span class="linenr"> 9: </span><span style="color: #7f7f7f;">         &#22914;com.companyname.project-group&#65292;</span>
<span class="linenr">10: </span><span style="color: #7f7f7f;">         maven&#20250;&#23558;&#35813;&#39033;&#30446;&#25171;&#25104;&#30340;jar&#21253;&#25918;&#26412;&#22320;&#36335;&#24452;&#65306;/com/companyname/project-group </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">11: </span>    &lt;<span style="color: SystemWindowText;">groupId</span>&gt;com.companyname.project-group&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#39033;&#30446;&#30340;&#21807;&#19968;ID&#65292;&#19968;&#20010;groupId&#19979;&#38754; _&#21487;&#33021;&#22810;&#20010;&#39033;&#30446;_&#65292;&#23601;&#26159;&#38752;artifactId&#26469;&#21306;&#20998;&#30340; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">14: </span>    &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;project&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#29256;&#26412;&#21495; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr">17: </span>    &lt;<span style="color: SystemWindowText;">version</span>&gt;1.0&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr">18: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<hr>
<p>
<b>Super POM</b>
</p>

<p>
所有的 POM 都继承自一个 <b>父 POM（Super POM）</b> （无论是否显式定义了这个父 POM）。
</p>

<p>
父 POM 包含了一些可以被继承的默认设置，使用 <code>mvn help:effective-pom</code> 命令来查看 Super POM 默认配置。
</p>

<blockquote>
<p>
Maven 使用 <code>effective pom</code> （Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 <code>pom.xml</code> 中做尽可能少的配置，当然这些配置可以被重写。
</p>
</blockquote>

<p>
你可以看到 Maven 在执行目标时需要用到的默认工程源码目录结构、输出目录、需要的插件、仓库和报表目录。
</p>

<p>
详细的 <code>pom.xml</code> 配置请查看 <a href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a>
</p>

<hr>
<p>
<b>Maven 依赖</b>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project...</span>&gt;
<span class="linenr"> 2: </span>    ...
<span class="linenr"> 3: </span>    &lt;<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr"> 4: </span>        &lt;<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 5: </span>            &lt;<span style="color: SystemWindowText;">groupId</span>&gt;commons-logging&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr"> 6: </span>            &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;commons-logging&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr"> 7: </span>            &lt;<span style="color: SystemWindowText;">version</span>&gt;1.2&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr"> 8: </span>        &lt;/<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 9: </span>        ...
<span class="linenr">10: </span>    &lt;/<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr">11: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<p>
使用 <code>&lt;dependency&gt;</code> 声明一个依赖后，Maven 就会自动下载这个依赖包并把它放到 classpath 中。 Maven使用 <code>groupId，artifactId</code> 和 <code>version</code> 唯一定位一个依赖。
</p>
</div>
</div>

<div id="outline-container-org689d86c" class="outline-3">
<h3 id="org689d86c">依赖管理</h3>
<div class="outline-text-3" id="text-org689d86c">
<p>
Maven 的第一个作用就是解决依赖管理。我们声明了自己的项目需要 <code>abc</code> ，Maven会自动导入 <code>abc</code> 的 jar包，再判断出 <code>abc</code> 需要 <code>xyz</code> ，又会自动导入 <code>xyz</code> 的jar包 ……
</p>

<p>
如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。
</p>

<p>
<b>依赖关系</b>
</p>

<p>
Maven定义了几种依赖关系，分别是 <code>compile、test、runtime</code> 和 <code>provided</code> 。
</p>

<p>
默认的 <code>compile</code> 是最常用的，Maven会把这种类型的依赖直接放入 classpath 。
</p>

<p>
<code>test</code> 依赖表示仅在测试时使用，正常运行时并不需要，如 JUnit 。
</p>

<p>
<code>runtime</code> 依赖表示编译时不需要，但运行时需要。最典型的 <code>runtime</code> 依赖是 JDBC 驱动，例如 MySQL驱动。
</p>

<p>
<code>provided</code> 依赖表示编译时需要，但运行时不需要。最典型的 <code>provided</code> 依赖是 <code>Servlet API</code> ，编译的时候需要，但是运行时，Servlet服务器内置了相关的 jar，所以运行期不需要。
</p>

<essay>
比如，运行的时候，Servlet 容器 Tomcat 会提供相关的 Servlet API 。
</essay>

<p>
<b>搜索第三方组件</b>
</p>

<p>
通过 <a href="https://search.maven.org/">search.maven.org</a> 搜索关键字，找到对应的组件后，直接复制。
</p>
</div>
</div>

<div id="outline-container-orgd43dd8a" class="outline-3">
<h3 id="orgd43dd8a">Maven 镜像</h3>
<div class="outline-text-3" id="text-orgd43dd8a">
<p>
中国区用户可以使用阿里云提供的 Maven 镜像仓库。使用 Maven 镜像仓库需要一个配置，在用户主目录下进入 <code>.m2</code> 目录，创建一个 <code>settings.xml</code> 配置文件，内容如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">settings</span>&gt;
<span class="linenr"> 2: </span>    &lt;<span style="color: SystemWindowText;">mirrors</span>&gt;
<span class="linenr"> 3: </span>        &lt;<span style="color: SystemWindowText;">mirror</span>&gt;
<span class="linenr"> 4: </span>            &lt;<span style="color: SystemWindowText;">id</span>&gt;aliyun&lt;/<span style="color: SystemWindowText;">id</span>&gt;
<span class="linenr"> 5: </span>            &lt;<span style="color: SystemWindowText;">name</span>&gt;aliyun&lt;/<span style="color: SystemWindowText;">name</span>&gt;
<span class="linenr"> 6: </span>            &lt;<span style="color: SystemWindowText;">mirrorOf</span>&gt;central&lt;/<span style="color: SystemWindowText;">mirrorOf</span>&gt;
<span class="linenr"> 7: </span>            <span style="color: #7f7f7f;">&lt;!-- </span><span style="color: #7f7f7f;">&#22269;&#20869;&#25512;&#33616;&#38463;&#37324;&#20113;&#30340;Maven&#38236;&#20687; </span><span style="color: #7f7f7f;">--&gt;</span>
<span class="linenr"> 8: </span>            &lt;<span style="color: SystemWindowText;">url</span>&gt;https://maven.aliyun.com/repository/central&lt;/<span style="color: SystemWindowText;">url</span>&gt;
<span class="linenr"> 9: </span>        &lt;/<span style="color: SystemWindowText;">mirror</span>&gt;
<span class="linenr">10: </span>    &lt;/<span style="color: SystemWindowText;">mirrors</span>&gt;
<span class="linenr">11: </span>&lt;/<span style="color: SystemWindowText;">settings</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge46948e" class="outline-3">
<h3 id="orge46948e"><span class="todo TODO">TODO</span> 构建流程</h3>
<div class="outline-text-3" id="text-orge46948e">
<p>
……
</p>
</div>
</div>
</div>

<div id="outline-container-orgfa55330" class="outline-2">
<h2 id="orgfa55330"><span class="todo TODO">TODO</span> 多线程</h2>
<div class="outline-text-2" id="text-orgfa55330">
</div>
<div id="outline-container-org55ba8d0" class="outline-3">
<h3 id="org55ba8d0">线程和进程</h3>
<div class="outline-text-3" id="text-org55ba8d0">
<p>
进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。
</p>

<img
src="images/java-43.jpg"
width="660"
height=""
style=""
title=""
/>

<p>
操作系统调度的最小任务单位其实不是进程，而是线程。
</p>

<p>
相对进程来说，创建线程开销小、通信快（线程间通信就是读写同一个变量）。多进程的好处在于稳定性好，一个进程崩溃不会影响其他进程。
</p>

<p>
Java 语言内置了多线程的支持：一个 Java 程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行 <code>main()</code> 方法，在 <code>main()</code> 方法内部，我们又可以启动多个线程。此外，JVM 还有负责垃圾回收的其他工作线程等。
</p>

<p>
因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。
</p>

<p>
Java多线程编程的特点又在于：
</p>

<ul class="org-ul">
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
</div>
</div>

<div id="outline-container-org0bf1885" class="outline-3">
<h3 id="org0bf1885">创建新线程</h3>
<div class="outline-text-3" id="text-org0bf1885">
<p>
要创建一个新线程非常容易，我们需要实例化一个 <code>Thread</code> 实例，然后调用它的 <code>start()</code> 方法：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Main</span> <span style="color: #707183;">{</span>
<span class="linenr">2: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">main</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">String</span><span style="color: #909183;">[]</span> <span style="color: SystemWindowText;">args</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr">3: </span>        <span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">Thread</span><span style="color: #909183;">()</span>;
<span class="linenr">4: </span>        t.start<span style="color: #909183;">()</span>; <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#21551;&#21160;&#26032;&#32447;&#31243;</span>
<span class="linenr">5: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">6: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
但是这个线程启动后实际上什么也不做就立刻结束了。
</p>

<p>
我们希望新线程能执行指定的代码，有以下几种方法：
</p>

<ol class="org-ol">
<li>从 <code>Thread</code> 派生一个自定义类，然后覆写 <code>run()</code> 方法；</li>
<li>创建 <code>Thread</code> 实例时，传入一个 <code>Runnable</code> 实例；</li>
<li>或用Java8引入的 lambda语法。</li>
</ol>

<blockquote>
<p>
小结：
</p>
<ul class="org-ul">
<li>Java用 <code>Thread</code> 对象表示一个线程，通过调用 <code>start()</code> 启动一个新线程；</li>
<li>一个线程对象只能调用一次 <code>start()</code> 方法；</li>
<li>线程的执行代码写在 <code>run()</code> 方法中；</li>
<li>线程调度由操作系统决定，程序本身无法决定调度顺序。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org9e31a52" class="outline-3">
<h3 id="org9e31a52">线程的状态</h3>
<div class="outline-text-3" id="text-org9e31a52">
<p>
在Java程序中，一个线程对象只能调用一次 <code>start()</code> 方法启动新线程，并在新线程中执行 <code>run()</code> 方法。一旦 <code>run()</code> 方法执行完毕，线程就结束了。
</p>

<img
src="images/java-44.jpg"
width="300"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
如图所示，Java线程的状态有以下几种：
</p>

<ul class="org-ul">
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行 <code>run()</code> 方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行 <code>sleep()</code> 方法正在计时等待；</li>
<li>Terminated：线程已终止，因为 <code>run()</code> 方法执行完毕。</li>
</ul>

<p>
当线程启动后，它可以在 <code>Runnable、Blocked、Waiting</code> 和 <code>Timed Waiting</code> 这几个状态之间切换，直到最后变成 <code>Terminated</code> 状态，线程终止。
</p>

<p>
线程终止的原因有：
</p>

<ul class="org-ul">
<li>线程正常终止： <code>run()</code> 方法执行到return语句返回；</li>
<li>线程意外终止： <code>run()</code> 方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的 Thread实例调用 <code>stop()</code> 方法强制终止（强烈不推荐使用）。</li>
</ul>

<p>
通过对另一个线程对象调用 <code>join()</code> 方法可以等待其执行结束,对已经运行结束的线程调用 <code>join()</code> 方法会立刻返回。
</p>
</div>
</div>

<div id="outline-container-org46885ce" class="outline-3">
<h3 id="org46885ce">中断线程</h3>
<div class="outline-text-3" id="text-org46885ce">
<p>
<code>main</code> 线程通过调用 <code>t.interrupt()</code> 方法中断 <code>t</code> 线程，但是要注意， <code>interrupt()</code> 方法仅仅向 <code>t</code> 线程发出了“中断请求”，至于 <code>t</code> 线程是否能立刻响应，要看具体代码。
</p>

<blockquote>
<p>
小结：
</p>

<p>
对目标线程调用 <code>interrupt()</code> 方法可以请求中断一个线程，目标线程通过检测 <code>isInterrupted()</code> 标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到 <code>InterruptedException</code> ；
</p>

<p>
目标线程检测到 <code>isInterrupted()</code> 为 <code>true</code> 或者捕获了 <code>InterruptedException</code> 都应该立刻结束自身线程；
</p>

<p>
通过标志位判断需要正确使用 <code>volatile</code> 关键字；=volatile= 关键字解决了共享变量在线程间的可见性问题。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org7fff4b0" class="outline-3">
<h3 id="org7fff4b0">守护进程</h3>
<div class="outline-text-3" id="text-org7fff4b0">
<p>
守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
</p>

<p>
如何创建守护线程呢？方法和普通线程一样，只是在调用 <code>start()</code> 方法前，调用 <code>setDaemon(true)</code> 该线程标记为守护线程：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #a020f0;">Thread</span> <span style="color: SystemWindowText;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #a020f0;">MyThread</span><span style="color: #707183;">()</span>;
<span class="linenr">2: </span>t.setDaemon<span style="color: #707183;">(</span><span style="color: #a020f0;">true</span><span style="color: #707183;">)</span>;
<span class="linenr">3: </span>t.start<span style="color: #707183;">()</span>;
</pre>
</div>

<p>
在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。
</p>
</div>
</div>

<div id="outline-container-org35c6f95" class="outline-3">
<h3 id="org35c6f95">线程同步</h3>
<div class="outline-text-3" id="text-org35c6f95">
<p>
当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。
</p>

<p>
多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以 <b>原子方式</b> 执行：即某一个线程执行时，其他线程必须等待。
</p>

<blockquote>
<p>
<b>*原子操作是指不能被中断的一个或一系列操作。</b>
</p>
</blockquote>

<p>
如，对于语句 <code>n = n + 1;</code> ，看上去是一行语句，实际上对应了 3 条指令：
</p>

<pre class="example">
ILOAD
IADD
ISTORE
</pre>

<img
src="images/java-45.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✘
</p>

<img
src="images/java-46.jpg"
width="260"
height=""
style=""
title=""
/>

<p>
✔
</p>

<p>
通过加锁和解锁的操作，就能保证 3 条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。
</p>

<p>
即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为 <span class="underline"><b>临界区</b> （Critical Section）</span> ，任何时候临界区最多只有一个线程能执行。
</p>

<p>
<b>可见，保证一段代码的原子性就是通过加锁和解锁实现的。</b>
</p>

<p>
Java程序使用 <code>synchronized</code> 关键字对一个对象进行加锁， <code>synchronized</code> 保证了代码块在任意时刻最多只有一个线程能执行。
</p>

<p>
如何使用 <code>synchronized</code> ：
</p>

<ul class="org-ul">
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用 <code>synchronized(lockObject) { ... }</code> 。</li>
</ul>

<p>
*因为 <code>synchronized</code> 代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以， <code>synchronized</code> 会降低程序的执行效率。
</p>

<p>
JVM 只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。因此，使用 <code>synchronized</code> 的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。
</p>

<blockquote>
<p>
小结：
</p>

<ul class="org-ul">
<li>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过 <code>synchronized</code> 同步；</li>
<li>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</li>
<li>注意加锁对象必须是同一个实例；</li>
<li>对 JVM 定义的单个原子操作不需要同步。</li>
</ul>
</blockquote>
</div>
</div>

<div id="outline-container-org1dd1fff" class="outline-3">
<h3 id="org1dd1fff">同步方法</h3>
<div class="outline-text-3" id="text-org1dd1fff">
<p>
让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装，更好的方法是把 <code>synchronized</code> 逻辑封装起来。如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #a020f0;">Counter</span> <span style="color: #707183;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">private</span> <span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">count</span> = 0;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr"> 5: </span>        <span style="color: #a020f0;">synchronized</span><span style="color: #909183;">(</span><span style="color: #a020f0;">this</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
<span class="linenr"> 6: </span>            count += n;
<span class="linenr"> 7: </span>        <span style="color: #909183;">}</span>
<span class="linenr"> 8: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">dec</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span>
<span class="linenr">11: </span>        <span style="color: #a020f0;">synchronized</span><span style="color: #909183;">(</span><span style="color: #a020f0;">this</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
<span class="linenr">12: </span>            count -= n;
<span class="linenr">13: </span>        <span style="color: #909183;">}</span>
<span class="linenr">14: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #a020f0;">public</span> <span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">get</span><span style="color: #7388d6;">()</span> <span style="color: #7388d6;">{</span>
<span class="linenr">17: </span>        <span style="color: #a020f0;">return</span> count;
<span class="linenr">18: </span>    <span style="color: #7388d6;">}</span>
<span class="linenr">19: </span><span style="color: #707183;">}</span>
</pre>
</div>

<p>
如此，线程调用 <code>add()</code> 、 <code>dec()</code> 方法时，它不必关心同步逻辑，因为 <code>synchronized</code> 代码块在 <code>add()</code> 、 <code>dec()</code> 方法内部。并且， <code>synchronized</code> 锁住的对象是 <code>this</code> ，即当前实例，这又使得创建多个 <code>Counter</code> 实例的时候，它们之间互不影响，可以并发执行。
</p>

<p>
如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。
</p>

<p>
*没有特殊说明时，一个类默认是非线程安全的。
</p>

<p>
当我们锁住的是 <code>this</code> 实例时，实际上可以用 <code>synchronized</code> 修饰这个方法。下面两种写法是等价的：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #707183;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #a020f0;">synchronized</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">this</span><span style="color: #7388d6;">)</span> <span style="color: #7388d6;">{</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#38145;&#20303;this</span>
<span class="linenr"> 3: </span>        count += n;
<span class="linenr"> 4: </span>    <span style="color: #7388d6;">}</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#35299;&#38145;</span>
<span class="linenr"> 5: </span><span style="color: #707183;">}</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#31561;&#20215;&#20110;</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">synchronized</span> <span style="color: #a020f0;">void</span> <span style="color: SystemWindowText;">add</span><span style="color: #707183;">(</span><span style="color: #a020f0;">int</span> <span style="color: SystemWindowText;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#38145;&#20303;this</span>
<span class="linenr">10: </span>    count += n;
<span class="linenr">11: </span><span style="color: #707183;">}</span> <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">&#35299;&#38145;</span>
</pre>
</div>

<p>
<b>因此，用 <code>synchronized</code> 修饰的方法就是同步方法，它表示整个方法都必须用 <code>this</code> 实例加锁。</b>
</p>
</div>
</div>
</div>

<div id="outline-container-orgbf641b8" class="outline-2">
<h2 id="orgbf641b8">Web 开发</h2>
<div class="outline-text-2" id="text-orgbf641b8">
</div>
<div id="outline-container-org9be0100" class="outline-3">
<h3 id="org9be0100">JavaEE</h3>
<div class="outline-text-3" id="text-org9be0100">
<p>
JavaEE 是完全基于JavaSE，只是多了一大堆服务器相关的库以及 API 接口。所有的 JavaEE 程序，仍然是运行在标准的 JavaSE 的虚拟机上的。
</p>

<p>
JavaEE 并不是一个软件产品，它更多的是一种软件架构和设计思想。我们可以把 JavaEE 看作是在 JavaSE 的基础上，开发的一系列基于服务器的组件、API标准和通用架构。
</p>

<img
src="images/java-48.jpg"
width="120"
height=""
style="float: right; margin-left: 8px;"
title=""
/>

<p>
<b>JavaEE 最核心的组件就是基于 Servlet标准的Web服务器</b> （如 Tomcat），开发者编写的应用程序是基于 Servlet API 并运行在 Web服务器内部的。
</p>

<p>
目前流行的基于 Spring 的轻量级 JavaEE 开发架构，使用最广泛的是 Servlet 和 JMS ，以及一系列开源组件。
</p>
</div>
</div>

<div id="outline-container-org5a99c74" class="outline-3">
<h3 id="org5a99c74">Web 基础</h3>
<div class="outline-text-3" id="text-org5a99c74">
<p>
<b>HTTP 协议（需要单独深入一下）</b>
</p>

<p>
HTTP 协议是一个基于 TCP 协议之上的请求-响应协议。
</p>

<p>
通常浏览器获取的 <b>第一个资源</b> 是 HTML 网页，在网页中，如果嵌入了 JavaScript、 CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。
</p>

<p>
如何编写 HTTP Server ？
</p>

<p>
一个 HTTP Server 本质上是一个 TCP 服务器，我们可以用 TCP 编程的多线程来实现一个服务器端框架。
</p>
</div>
</div>

<div id="outline-container-org1eda366" class="outline-3">
<h3 id="org1eda366">Servlet</h3>
<div class="outline-text-3" id="text-org1eda366">
<p>
我们看到，编写 HTTP 服务器其实是非常简单的，只需要先编写基于多线程的 TCP 服务，然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可。
</p>

<p>
但是，要编写一个完善的HTTP服务器，需要考虑好多方面，经过长期测试才能稳定运行。
</p>

<p>
因此，在 JavaEE 平台上，处理 TCP 连接，解析 HTTP 协议这些底层工作统统扔给现成的 Web 服务器去做，我们只需要把自己的应用程序跑在 Web 服务器上。
</p>

<p>
为了实现这一目的， <b>JavaEE 提供了 Servlet API</b> ， <b>Web 服务器实现 Servlet API 接口</b> ，实现底层功能。 <b>我们使用 Servlet API 编写自己的 Servlet</b> 来处理 HTTP 请求。
</p>

<p>
一个 Servlet 总是继承自 <code>HttpServlet</code> ，然后覆写 <code>doGet()</code> 或 <code>doPost()</code> 方法。它们接收 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 两个对象做为参数，分别代表 HTTP 请求和响应。
</p>

<p>
我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 <code>PrintWriter</code> ，写入响应即可。
</p>

<p>
<b>Servlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。</b>
</p>

<p>
看一下伪示例的 <code>pom.xml</code> 文件如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: SystemWindowText;">project...</span>&gt;
<span class="linenr"> 2: </span>    ...
<span class="linenr"> 3: </span>    &lt;<span style="color: SystemWindowText;">packaging</span>&gt;war&lt;/<span style="color: SystemWindowText;">packaging</span>&gt;
<span class="linenr"> 4: </span>    ...
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    &lt;<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr"> 7: </span>        &lt;<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr"> 8: </span>            &lt;<span style="color: SystemWindowText;">groupId</span>&gt;javax.servlet&lt;/<span style="color: SystemWindowText;">groupId</span>&gt;
<span class="linenr"> 9: </span>            &lt;<span style="color: SystemWindowText;">artifactId</span>&gt;javax.servlet-api&lt;/<span style="color: SystemWindowText;">artifactId</span>&gt;
<span class="linenr">10: </span>            &lt;<span style="color: SystemWindowText;">version</span>&gt;4.0.0&lt;/<span style="color: SystemWindowText;">version</span>&gt;
<span class="linenr">11: </span>            &lt;<span style="color: SystemWindowText;">scope</span>&gt;provided&lt;/<span style="color: SystemWindowText;">scope</span>&gt;
<span class="linenr">12: </span>        &lt;/<span style="color: SystemWindowText;">dependency</span>&gt;
<span class="linenr">13: </span>    &lt;/<span style="color: SystemWindowText;">dependencies</span>&gt;
<span class="linenr">14: </span>    ...
<span class="linenr">15: </span>&lt;/<span style="color: SystemWindowText;">project</span>&gt;
</pre>
</div>

<p>
注意 <code>&lt;packaging&gt;war&lt;/packaging&gt;</code> ，打包的类型不是 <code>jar</code> ，而是 <code>war</code> ； <code>&lt;scope&gt;</code> 指定为 <code>provided</code> ，表示编译时使用，但不会打包到 <code>.war</code> 文件中，因为运行期 Web 服务器本身已经提供了 Servlet API 相关的 jar 包。
</p>

<hr>
<p>
<b>web.xml</b>
</p>

<p>
我们还需要在工程目录下创建一个 <code>web.xml</code> 描述文件，放到 <code>src/main/webapp/WEB-INF</code> 目录下（固定目录结构，不要修改路径，注意大小写）。如：
</p>

<img
src="images/java-49.jpg"
width="430"
height=""
style=""
title=""
/>

<p>
运行 Maven 命令 <code>mvn clean package</code> ，在 <code>target</code> 目录下得到一个 <code>hello.war</code> 文件，这个文件就是我们编译打包后的 Web 应用程序。
</p>

<hr>
<p>
<b>我们应该如何运行这个 <code>war</code> 文件？</b>
</p>

<p>
普通的 Java 程序是通过启动 JVM，然后执行 <code>main()</code> 方法开始运行。 但是 Web 应用程序有所不同， <b>我们无法直接运行 <code>war</code> 文件</b> ，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 <code>HelloServlet</code> ，这样就可以让 <code>HelloServlet</code> 处理浏览器发送的请求。
</p>

<p>
因此，我们首先要找一个支持 Servlet API 的 Web 服务器。常用的服务器有：
</p>

<ul class="org-ul">
<li>Tomcat：由Apache开发的开源免费服务器；</li>
<li>Jetty：由Eclipse开发的开源免费服务器；</li>
<li>GlassFish：一个开源的全功能JavaEE服务器。</li>
</ul>

<p>
无论使用哪个服务器，只要它支持 Servlet API 4.0（因为我们引入的Servlet版本是4.0），我们的 war 包都可以在上面运行。
</p>

<blockquote>
<p>
实际上，类似 Tomcat 这样的服务器也是 Java 编写的，启动 Tomcat 服务器实际上是启动 Java 虚拟机，执行 Tomcat 的 <code>main()</code> 方法，然后由 Tomcat 负责加载我们的 <code>.war</code> 文件，并创建一个 <code>HelloServlet</code> 实例，最后以多线程的模式来处理 HTTP 请求。
</p>
</blockquote>

<p>
因为我们编写的 Servlet 并不是直接运行，而是由 Web 服务器加载后创建实例运行，所以，类似 Tomcat 这样的 Web 服务器也称为 <span class="underline">Servlet 容器</span> 。
</p>

<p>
在 Servlet 容器中运行的 Servlet 具有如下特点：
</p>

<ul class="org-ul">
<li>无法在代码中直接通过 <code>new</code> 创建 <code>Servlet</code> 实例，必须由 Servlet 容器自动创建 Servlet 实例；</li>
<li>Servlet 容器只会给每个 Servlet 类创建唯一实例；</li>
<li>Servlet 容器会使用多线程执行 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li>……</li>
<li>在 Servlet 中定义的实例变量会被多个线程同时访问，要注意线程安全；</li>
<li><code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 实例是由 Servlet 容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；</li>
<li>在 <code>doGet()</code> 或 <code>doPost()</code> 方法中，如果使用了 ThreadLocal，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为 Servlet 容器很可能用线程池实现线程复用。</li>
</ul>

<p>
因此，正确编写 Servlet，要清晰理解 Java 的多线程模型，需要同步访问的必须同步。
</p>
</div>
</div>

<div id="outline-container-orgab0faa8" class="outline-3">
<h3 id="orgab0faa8">Servlet 开发</h3>
<div class="outline-text-3" id="text-orgab0faa8">
<p>
一个完整的 Web 应用程序的开发流程如下：
</p>

<ul class="org-ul">
<li>编写 Servlet；</li>
<li>打包为 war 文件；</li>
<li>复制到 Tomcat 的 webapps 目录下；</li>
<li>启动 Tomcat。</li>
</ul>

<p>
许多初学者经常卡在如何在 IDE 中启动 Tomcat 并加载 webapp，更不要说断点调试了……
</p>

<p>
……
</p>

<p>
因为 Tomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：
</p>

<ul class="org-ul">
<li>启动 JVM 并执行 Tomcat 的 <code>main()</code> 方法；</li>
<li>加载 war 并初始化 Servlet；</li>
<li>正常服务。</li>
</ul>

<p>
启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 <code>main()</code> 方法，我们完全可以 <b>把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 <code>main()</code> 方法</b> ，先启动 Tomcat，然后让它加载我们的 webapp 就行。
</p>

<blockquote>
<p>
现在好了，SpringBoot 支持在 <code>main()</code> 方法中一行代码直接启动 Tomcat 。
</p>
</blockquote>

<p>
*开发 Servlet 时，推荐使用 <code>main()</code> 方法启动嵌入式 Tomcat 服务器并加载当前工程的 webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-04-04 Sun 17:23</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-04-09 Fri 17:44</p>
<p class="validation"><a href="http://beian.miit.gov.cn/">豫ICP备19025929号</a></p>
</div>
</body>
</html>
