<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-03-17 Wed 19:41 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Vue Inbox</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="themes/assets/rose-red.png" type="image/x-icon" />
           <link rel="stylesheet" href="themes/style.css" type="text/css"  />
           <script type="module" src="themes/main.js" defer></script>
</head>
<body>
<div id="content">
<h1 class="title">Vue Inbox</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga11b067">Vue Inbox</a>
<ul>
<li><a href="#org1adcc04">声明式渲染</a></li>
<li><a href="#orgcaeed6b">处理用户输入</a></li>
<li><a href="#org355f651">组件化应用构建</a></li>
<li><a href="#orga943d32">Vue 实例</a></li>
<li><a href="#org70ad77f">模板语法</a></li>
<li><a href="#orga8d0063">计算属性</a></li>
<li><a href="#org1e6f55c">绑定 HTML Class</a></li>
<li><a href="#org75b509c">绑定内联样式</a></li>
<li><a href="#org42bc803">条件渲染和列表渲染</a></li>
<li><a href="#org5ec4c00">事件处理</a></li>
<li><a href="#orga352bf7">表单输入绑定</a></li>
<li><a href="#org10cfeb2">组件基础</a></li>
</ul>
</li>
<li><a href="#orgcd455de">深入了解组件</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga11b067" class="outline-2">
<h2 id="orga11b067">Vue Inbox</h2>
<div class="outline-text-2" id="text-orga11b067">
</div>
<div id="outline-container-org1adcc04" class="outline-3">
<h3 id="org1adcc04">声明式渲染</h3>
<div class="outline-text-3" id="text-org1adcc04">
<p>
Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。
</p>

<p>
数据和 DOM 已经被建立了关联，所有东西都是响应式的。
</p>

<p>
我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上，然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。
</p>
</div>
</div>

<div id="outline-container-orgcaeed6b" class="outline-3">
<h3 id="orgcaeed6b">处理用户输入</h3>
<div class="outline-text-3" id="text-orgcaeed6b">
<p>
为了让用户和你的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法。
</p>

<p>
Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。
</p>
</div>
</div>

<div id="outline-container-org355f651" class="outline-3">
<h3 id="org355f651">组件化应用构建</h3>
<div class="outline-text-3" id="text-org355f651">
<p>
组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。
</p>

<p>
在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。
</p>
</div>
</div>

<div id="outline-container-orga943d32" class="outline-3">
<h3 id="orga943d32">Vue 实例</h3>
<div class="outline-text-3" id="text-orga943d32">
<p>
<b>创建一个 Vue 实例</b>
</p>

<p>
每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的，当创建一个 Vue 实例时，你可以传入一个 <b>选项对象</b> 。
</p>

<p>
一个 Vue 应用由一个通过 <code>new Vue</code> 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。
</p>

<hr>
<p>
<b>数据与方法</b>
</p>

<p>
当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。
</p>

<p>
*值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。
</p>

<p>
使用 <code>Object.freeze()</code> ，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。
</p>

<p>
除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 <code>$</code> ，以便与用户定义的 property 区分开来。
</p>
</div>
</div>

<div id="outline-container-org70ad77f" class="outline-3">
<h3 id="org70ad77f">模板语法</h3>
<div class="outline-text-3" id="text-org70ad77f">
<p>
在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。
</p>

<p>
如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。
</p>

<p>
更多关于 <a href="https://cn.vuejs.org/v2/guide/render-function.html">渲染函数 &amp; JSX</a> 。
</p>

<p>
数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。
</p>

<p>
Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <code>v-bind</code> 指令。
</p>

<p>
实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。
</p>

<p>
*限制就是，每个绑定都只能包含单个表达式。
</p>

<p>
一些指令能够接收一个“参数”，在指令名称之后以冒号表示。如：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">a</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">href</span>=<span style="color: #50a14f;">"url"</span>&gt;...&lt;/<span style="color: #a626a4;">a</span>&gt;
<span class="linenr">2: </span>&lt;<span style="color: #a626a4;">a</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"doSomething"</span>&gt;...&lt;/<span style="color: #a626a4;">a</span>&gt;
</pre>
</div>

<p>
从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数。
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#65288;&#21160;&#24577;&#21442;&#25968;&#65289; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">2: </span>&lt;<span style="color: #a626a4;">a</span> v-bind:[attributeName]=<span style="color: #50a14f;">"url"</span>&gt; ... &lt;/<span style="color: #a626a4;">a</span>&gt;
</pre>
</div>

<p>
动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。
</p>

<p>
修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如， <code>.prevent</code> 修饰符告诉 v-on 指令对于触发的事件调用 <code>event.preventDefault()</code> 。
</p>
</div>
</div>

<div id="outline-container-orga8d0063" class="outline-3">
<h3 id="orga8d0063">计算属性</h3>
<div class="outline-text-3" id="text-orga8d0063">
<p>
模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。
</p>

<essay>
编写代码一定要注意语义表述的简洁性和可读性。
</essay>

<p>
*对于任何复杂逻辑，你都应当使用计算属性。
</p>

<p>
你可以像绑定普通 property 一样在模板中绑定计算属性。计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。
</p>

<p>
<b>计算属性缓存 vs 方法</b>
</p>

<p>
我们可以将同一函数定义为一个方法而不是一个计算属性。不同的是 <b>计算属性是基于它们的响应式依赖进行缓存的</b> ，只在相关响应式依赖发生改变时它们才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
</p>

<p>
计算属性默认只有 getter，不过在需要时你也可以提供一个 setter 。
</p>

<p>
<b>计算属性 vs 侦听属性</b>
</p>

<p>
Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。
</p>

<p>
！当需要在数据变化时执行异步或开销较大的操作时，这个方式（侦听属性）是最有用的。
</p>

<p>
使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。
</p>
</div>
</div>

<div id="outline-container-org1e6f55c" class="outline-3">
<h3 id="org1e6f55c">绑定 HTML Class</h3>
<div class="outline-text-3" id="text-org1e6f55c">
<p>
在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。
</p>

<essay>
结构化的数据总是更便于处理的。
</essay>

<p>
<b>1.对象语法</b>
</p>

<p>
我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">class</span>=<span style="color: #50a14f;">"{ active: isActive }"</span>&gt;&lt;/<span style="color: #a626a4;">div</span>&gt;
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#21487;&#20197;&#22312;&#23545;&#35937;&#20013;&#20256;&#20837;&#26356;&#22810;&#23383;&#27573;&#26469;&#21160;&#24577;&#20999;&#25442;&#22810;&#20010; class </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">4: </span>&lt;<span style="color: #a626a4;">div</span>
<span class="linenr">5: </span>  <span style="color: #6a1868;">class</span>=<span style="color: #50a14f;">"static"</span>
<span class="linenr">6: </span>  <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">class</span>=<span style="color: #50a14f;">"{ active: isActive, 'text-danger': hasError }"</span>
<span class="linenr">7: </span>&gt;&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>

<p>
绑定的数据对象不必内联定义在模板里：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;</span>
<span class="linenr">2: </span>
<span class="linenr">3: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr">4: </span>  classObject: <span style="color: #a626a4;">{</span>
<span class="linenr">5: </span>    active: <span style="color: #b751b6;">true</span>,
<span class="linenr">6: </span>    <span style="color: #50a14f;">'text-danger'</span>: <span style="color: #b751b6;">false</span>
<span class="linenr">7: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">8: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<p>
我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr"> 4: </span>  isActive: <span style="color: #b751b6;">true</span>,
<span class="linenr"> 5: </span>  error: <span style="color: #b751b6;">null</span>
<span class="linenr"> 6: </span><span style="color: #4078f2;">}</span>,
<span class="linenr"> 7: </span>computed: <span style="color: #4078f2;">{</span>
<span class="linenr"> 8: </span>  <span style="color: #a626a4;">classObject</span>: <span style="color: #e45649;">function</span> <span style="color: #a626a4;">()</span> <span style="color: #a626a4;">{</span>
<span class="linenr"> 9: </span>    <span style="color: #e45649;">return</span> <span style="color: #50a14f;">{</span>
<span class="linenr">10: </span>      active: <span style="color: #b751b6;">this</span>.isActive &amp;&amp; !<span style="color: #b751b6;">this</span>.error,
<span class="linenr">11: </span>      <span style="color: #50a14f;">'text-danger'</span>: <span style="color: #b751b6;">this</span>.error &amp;&amp; <span style="color: #b751b6;">this</span>.error.type === <span style="color: #50a14f;">'fatal'</span>
<span class="linenr">12: </span>    <span style="color: #50a14f;">}</span>
<span class="linenr">13: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">14: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<hr>
<p>
<b>2.数组语法</b>
</p>

<p>
我们可以把一个数组传给 v-bind:class，以应用一个 class 列表：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;</span>
<span class="linenr">2: </span>
<span class="linenr">3: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr">4: </span>  activeClass: <span style="color: #50a14f;">'active'</span>,
<span class="linenr">5: </span>  errorClass: <span style="color: #50a14f;">'text-danger'</span>
<span class="linenr">6: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<p>
渲染为：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #6a1868;">class</span>=<span style="color: #50a14f;">"active text-danger"</span>&gt;&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>

<p>
在数组语法中也可以使用对象语法：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">2: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#31561;&#20215;&#20110; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">3: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">class</span>=<span style="color: #50a14f;">"[{ active: isActive }, errorClass]"</span>&gt;&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>

<hr>
<p>
<b>3.用在组件上</b>
</p>

<p>
当在一个自定义组件上使用 class property 时，这些 class 将被添加到该 <b>组件的根元素</b> 上面。这个元素上已经存在的 class 不会被覆盖。
</p>
</div>
</div>

<div id="outline-container-org75b509c" class="outline-3">
<h3 id="org75b509c">绑定内联样式</h3>
<div class="outline-text-3" id="text-org75b509c">
<p>
<b>1.对象语法</b>
</p>

<p>
<code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。
</p>

<p>
CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;</span>
<span class="linenr">2: </span>
<span class="linenr">3: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr">4: </span>  activeColor: <span style="color: #50a14f;">'red'</span>,
<span class="linenr">5: </span>  fontSize: 30
<span class="linenr">6: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<p>
直接绑定到一个样式对象通常更好，这会让模板更清晰：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;</span>
<span class="linenr">2: </span>
<span class="linenr">3: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr">4: </span>  styleObject: <span style="color: #a626a4;">{</span>
<span class="linenr">5: </span>    color: <span style="color: #50a14f;">'red'</span>,
<span class="linenr">6: </span>    fontSize: <span style="color: #50a14f;">'13px'</span>
<span class="linenr">7: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">8: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<p>
同样的，对象语法常常结合返回对象的计算属性使用。
</p>

<hr>
<p>
<b>2.数组语法</b>
</p>

<p>
v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">style</span>=<span style="color: #50a14f;">"[baseStyles, overridingStyles]"</span>&gt;&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org42bc803" class="outline-3">
<h3 id="org42bc803">条件渲染和列表渲染</h3>
<div class="outline-text-3" id="text-org42bc803">
<p>
Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可。
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">template</span> <span style="color: #6a1868;">v-if</span>=<span style="color: #50a14f;">"loginType === 'username'"</span>&gt;
<span class="linenr">2: </span>  &lt;<span style="color: #a626a4;">label</span>&gt;Username&lt;/<span style="color: #a626a4;">label</span>&gt;
<span class="linenr">3: </span>  &lt;<span style="color: #a626a4;">input</span> <span style="color: #6a1868;">placeholder</span>=<span style="color: #50a14f;">"Enter your username"</span> <span style="color: #6a1868;">key</span>=<span style="color: #50a14f;">"username-input"</span>&gt;
<span class="linenr">4: </span>&lt;/<span style="color: #a626a4;">template</span>&gt;
<span class="linenr">5: </span>&lt;<span style="color: #a626a4;">template</span> v-else&gt;
<span class="linenr">6: </span>  &lt;<span style="color: #a626a4;">label</span>&gt;Email&lt;/<span style="color: #a626a4;">label</span>&gt;
<span class="linenr">7: </span>  &lt;<span style="color: #a626a4;">input</span> <span style="color: #6a1868;">placeholder</span>=<span style="color: #50a14f;">"Enter your email address"</span> <span style="color: #6a1868;">key</span>=<span style="color: #50a14f;">"email-input"</span>&gt;
<span class="linenr">8: </span>&lt;/<span style="color: #a626a4;">template</span>&gt;
</pre>
</div>

<p>
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将 <b>不会移动 DOM 元素来匹配数据项的顺序</b> ，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。
</p>

<p>
*这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
</p>

<p>
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #6a1868;">v-for</span>=<span style="color: #50a14f;">"item in items"</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">key</span>=<span style="color: #50a14f;">"item.id"</span>&gt;
<span class="linenr">2: </span>  <span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#20869;&#23481; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>

<p>
*不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。
</p>

<p>
当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。
</p>

<hr>
<p>
<b>数组更新检测</b>
</p>

<p>
Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
</p>

<pre class="example">
- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
</pre>

<p>
变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>filter()、concat()</code> 和 <code>slice()</code> 。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>example1.items = example1.items.filter<span style="color: #4078f2;">(</span><span style="color: #e45649;">function</span> <span style="color: #a626a4;">(</span><span style="color: #6a1868;">item</span><span style="color: #a626a4;">)</span> <span style="color: #a626a4;">{</span>
<span class="linenr">2: </span>    <span style="color: #e45649;">return</span> item.message.match<span style="color: #50a14f;">(</span><span style="color: #50a14f;">/Foo/</span><span style="color: #50a14f;">)</span>
<span class="linenr">3: </span><span style="color: #a626a4;">}</span><span style="color: #4078f2;">)</span>
</pre>
</div>

<p>
<b>！由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</b>
</p>

<hr>
<p>
<b>显示过滤/排序后的结果</b>
</p>

<p>
有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。
</p>

<p>
在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;ul v-for="set in sets"&gt;</span>
<span class="linenr"> 2: </span><span style="color: #9ca0a4;">//  </span><span style="color: #9ca0a4;">&lt;li v-for="n in even(set)"&gt;{{ n }}&lt;/li&gt;</span>
<span class="linenr"> 3: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;/ul&gt;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>data: <span style="color: #4078f2;">{</span>
<span class="linenr"> 6: </span>  sets: <span style="color: #a626a4;">[</span><span style="color: #50a14f;">[</span> 1, 2, 3, 4, 5 <span style="color: #50a14f;">]</span>, <span style="color: #50a14f;">[</span>6, 7, 8, 9, 10<span style="color: #50a14f;">]</span><span style="color: #a626a4;">]</span>
<span class="linenr"> 7: </span><span style="color: #4078f2;">}</span>,
<span class="linenr"> 8: </span>methods: <span style="color: #4078f2;">{</span>
<span class="linenr"> 9: </span>  <span style="color: #a626a4;">even</span>: <span style="color: #e45649;">function</span> <span style="color: #a626a4;">(</span><span style="color: #6a1868;">numbers</span><span style="color: #a626a4;">)</span> <span style="color: #a626a4;">{</span>
<span class="linenr">10: </span>    <span style="color: #e45649;">return</span> numbers.filter<span style="color: #50a14f;">(</span><span style="color: #e45649;">function</span> <span style="color: #da8548;">(</span><span style="color: #6a1868;">number</span><span style="color: #da8548;">)</span> <span style="color: #da8548;">{</span>
<span class="linenr">11: </span>      <span style="color: #e45649;">return</span> number % 2 === 0
<span class="linenr">12: </span>    <span style="color: #da8548;">}</span><span style="color: #50a14f;">)</span>
<span class="linenr">13: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">14: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<p>
v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。
</p>

<p>
类似于 v-if，你也可以利用带有 v-for 的 &lt;template&gt; 来循环渲染一段包含多个元素的内容。
</p>

<hr>
<p>
<b>v-for 与 v-if 一同使用</b>
</p>

<p>
当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用。而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 &lt;template&gt;) 上。
</p>

<hr>
<p>
<b>在组件上使用 v-for</b>
</p>

<p>
在自定义组件上，你可以像在任何普通元素上一样使用 v-for。然而，任何数据都不会被自动传递到组件里，因为 <b>组件有自己独立的作用域</b> 。 <b>为了把迭代数据传递到组件里，我们要使用 prop</b> 。
</p>

<blockquote>
<p>
不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。 <b>明确组件数据的来源能够使组件在其他场合重复使用</b> 。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org5ec4c00" class="outline-3">
<h3 id="org5ec4c00">事件处理</h3>
<div class="outline-text-3" id="text-org5ec4c00">
<p>
可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。
</p>

<p>
然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收 <b>一个需要调用的方法名称</b> 。
</p>

<p>
除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法。
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span> &lt;<span style="color: #a626a4;">button</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"counter += 1"</span>&gt;Add 1&lt;/<span style="color: #a626a4;">button</span>&gt;
<span class="linenr">2: </span>
<span class="linenr">3: </span> <span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">`greet` &#26159;&#22312;&#19979;&#38754;&#23450;&#20041;&#30340;&#26041;&#27861;&#21517; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">4: </span> &lt;<span style="color: #a626a4;">button</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"greet"</span>&gt;Greet&lt;/<span style="color: #a626a4;">button</span>&gt;
<span class="linenr">5: </span>
<span class="linenr">6: </span>&lt;<span style="color: #a626a4;">button</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"say('hi')"</span>&gt;Say hi&lt;/<span style="color: #a626a4;">button</span>&gt;
</pre>
</div>

<p>
<b>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</b>
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt;Submit&lt;/button&gt;</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">...</span>
<span class="linenr"> 4: </span>methods: <span style="color: #4078f2;">{</span>
<span class="linenr"> 5: </span>  <span style="color: #a626a4;">warn</span>: <span style="color: #e45649;">function</span> <span style="color: #a626a4;">(</span><span style="color: #6a1868;">message</span>, <span style="color: #6a1868;">event</span><span style="color: #a626a4;">)</span> <span style="color: #a626a4;">{</span>
<span class="linenr"> 6: </span>    <span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&#29616;&#22312;&#25105;&#20204;&#21487;&#20197;&#35775;&#38382;&#21407;&#29983;&#20107;&#20214;&#23545;&#35937;</span>
<span class="linenr"> 7: </span>    <span style="color: #e45649;">if</span> <span style="color: #50a14f;">(</span>event<span style="color: #50a14f;">)</span> <span style="color: #50a14f;">{</span>
<span class="linenr"> 8: </span>      event.preventDefault<span style="color: #da8548;">()</span>
<span class="linenr"> 9: </span>    <span style="color: #50a14f;">}</span>
<span class="linenr">10: </span>    alert<span style="color: #50a14f;">(</span>message<span style="color: #50a14f;">)</span>
<span class="linenr">11: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">12: </span><span style="color: #4078f2;">}</span>
</pre>
</div>

<hr>
<p>
<b>事件修饰符</b>
</p>

<p>
在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。
</p>

<p>
尽管我们可以在方法中轻松实现这点，但更好的方式是： <b>方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</b>
</p>

<p>
为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。
</p>

<pre class="example">
- .stop
- .prevent
- .capture
- .self
- .once
- .passive
</pre>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr"> 1: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#38459;&#27490;&#21333;&#20987;&#20107;&#20214;&#32487;&#32493;&#20256;&#25773; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr"> 2: </span>&lt;<span style="color: #a626a4;">a</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click.stop</span>=<span style="color: #50a14f;">"doThis"</span>&gt;&lt;/<span style="color: #a626a4;">a</span>&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#25552;&#20132;&#20107;&#20214;&#19981;&#20877;&#37325;&#36733;&#39029;&#38754; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr"> 5: </span>&lt;<span style="color: #a626a4;">form</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">submit.prevent</span>=<span style="color: #50a14f;">"onSubmit"</span>&gt;&lt;/<span style="color: #a626a4;">form</span>&gt;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#20462;&#39280;&#31526;&#21487;&#20197;&#20018;&#32852; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr"> 8: </span>&lt;<span style="color: #a626a4;">a</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click.stop.prevent</span>=<span style="color: #50a14f;">"doThat"</span>&gt;&lt;/<span style="color: #a626a4;">a</span>&gt;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#21482;&#26377;&#20462;&#39280;&#31526; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">11: </span>&lt;<span style="color: #a626a4;">form</span> v-on:submit.prevent&gt;&lt;/<span style="color: #a626a4;">form</span>&gt;
<span class="linenr">12: </span>
<span class="linenr">13: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#28155;&#21152;&#20107;&#20214;&#30417;&#21548;&#22120;&#26102;&#20351;&#29992;&#20107;&#20214;&#25429;&#33719;&#27169;&#24335; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">14: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#21363;&#20869;&#37096;&#20803;&#32032;&#35302;&#21457;&#30340;&#20107;&#20214;&#20808;&#22312;&#27492;&#22788;&#29702;&#65292;&#28982;&#21518;&#25165;&#20132;&#30001;&#20869;&#37096;&#20803;&#32032;&#36827;&#34892;&#22788;&#29702; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">15: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click.capture</span>=<span style="color: #50a14f;">"doThis"</span>&gt;...&lt;/<span style="color: #a626a4;">div</span>&gt;
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#21482;&#24403;&#22312; event.target &#26159;&#24403;&#21069;&#20803;&#32032;&#33258;&#36523;&#26102;&#35302;&#21457;&#22788;&#29702;&#20989;&#25968; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">18: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#21363;&#20107;&#20214;&#19981;&#26159;&#20174;&#20869;&#37096;&#20803;&#32032;&#35302;&#21457;&#30340; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">19: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click.self</span>=<span style="color: #50a14f;">"doThat"</span>&gt;...&lt;/<span style="color: #a626a4;">div</span>&gt;
<span class="linenr">20: </span>
<span class="linenr">21: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#28857;&#20987;&#20107;&#20214;&#23558;&#21482;&#20250;&#35302;&#21457;&#19968;&#27425; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">22: </span>&lt;<span style="color: #a626a4;">a</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click.once</span>=<span style="color: #50a14f;">"doThis"</span>&gt;&lt;/<span style="color: #a626a4;">a</span>&gt;
<span class="linenr">23: </span>
<span class="linenr">24: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">Vue &#36824;&#23545;&#24212; addEventListener &#20013;&#30340; passive &#36873;&#39033;&#25552;&#20379;&#20102; .passive &#20462;&#39280;&#31526; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">25: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#28378;&#21160;&#20107;&#20214;&#30340;&#40664;&#35748;&#34892;&#20026; (&#21363;&#28378;&#21160;&#34892;&#20026;) &#23558;&#20250;&#31435;&#21363;&#35302;&#21457; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">26: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#32780;&#19981;&#20250;&#31561;&#24453; `onScroll` &#23436;&#25104;  </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">27: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#36825;&#20854;&#20013;&#21253;&#21547; `event.preventDefault()` &#30340;&#24773;&#20917; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">28: </span>&lt;<span style="color: #a626a4;">div</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">scroll.passive</span>=<span style="color: #50a14f;">"onScroll"</span>&gt;...&lt;/<span style="color: #a626a4;">div</span>&gt;
</pre>
</div>

<blockquote>
<p>
使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orga352bf7" class="outline-3">
<h3 id="orga352bf7">表单输入绑定</h3>
<div class="outline-text-3" id="text-orga352bf7">
<p>
你可以用 v-model 指令在表单 <code>&lt;input&gt;、&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。
</p>

<p>
它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。 <b>它负责监听用户的输入事件以更新数据</b> ，并对一些极端场景进行一些特殊处理。
</p>

<blockquote>
<p>
v-model 会忽略所有表单元素的 <code>value、checked、selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。
</p>
</blockquote>

<p>
v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：
</p>
<ul class="org-ul">
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>

<blockquote>
<p>
对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org10cfeb2" class="outline-3">
<h3 id="org10cfeb2">组件基础</h3>
<div class="outline-text-3" id="text-org10cfeb2">
<p>
组件是可复用的 Vue 实例，且带有一个名字，它们与 new Vue 接收相同的选项，例如 <code>data、computed、watch、methods</code> 以及生命周期钩子等。
</p>

<p>
*仅有的例外是像 <code>el</code> 这样根实例特有的选项。
</p>

<p>
<b>一个组件的 data 选项必须是一个函数</b> ，因此每个实例可以维护一份被返回对象的独立的拷贝。
</p>

<p>
为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。
</p>

<p>
全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
</p>

<hr>
<p>
<b>通过 Prop 向子组件传递数据</b>
</p>

<p>
Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&#20840;&#23616;&#27880;&#20876; `blog-post` &#32452;&#20214;</span>
<span class="linenr">2: </span>Vue.component<span style="color: #4078f2;">(</span><span style="color: #50a14f;">'blog-post'</span>, <span style="color: #a626a4;">{</span>
<span class="linenr">3: </span>  props: <span style="color: #50a14f;">[</span><span style="color: #50a14f;">'title'</span><span style="color: #50a14f;">]</span>,
<span class="linenr">4: </span>  template: <span style="color: #50a14f;">'&lt;h3&gt;{{ title }}&lt;/h3&gt;'</span>
<span class="linenr">5: </span><span style="color: #a626a4;">}</span><span style="color: #4078f2;">)</span>
<span class="linenr">6: </span>
<span class="linenr">7: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&#19968;&#20010; prop &#34987;&#27880;&#20876;&#20043;&#21518;&#65292;&#20320;&#23601;&#21487;&#20197;&#20687;&#36825;&#26679;&#25226;&#25968;&#25454;&#20316;&#20026;&#19968;&#20010;&#33258;&#23450;&#20041; attribute &#20256;&#36882;&#36827;&#26469;</span>
<span class="linenr">8: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;blog-post title="My journey with Vue"&gt;&lt;/blog-post&gt;</span>
<span class="linenr">9: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;blog-post title="Blogging with Vue"&gt;&lt;/blog-post&gt;</span>
</pre>
</div>

<p>
*我们能够在组件实例中访问这个值，就像访问 data 中的值一样。
</p>

<p>
一个组件默认可以拥有任意数量的 prop， <b>任何值</b> 都可以传递给任何 prop。
</p>

<p>
<b>！每个组件必须只有一个根元素。</b>
</p>

<hr>
<p>
<b>监听子组件事件</b>
</p>

<p>
在我们开发 <code>&lt;blog-post&gt;</code> 组件时，它的一些功能可能要求我们和父级组件进行沟通。例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号。
</p>

<p>
Vue 实例提供了一个自定义事件的系统来解决这个问题。父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">blog-post</span>
<span class="linenr">2: </span>  ...
<span class="linenr">3: </span>  <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">enlarge-text</span>=<span style="color: #50a14f;">"postFontSize += 0.1"</span>
<span class="linenr">4: </span>&gt;&lt;/<span style="color: #a626a4;">blog-post</span>&gt;
</pre>
</div>

<p>
同时子组件可以通过调用内建的 <code>$emit</code> 方法并传入事件名称来触发一个事件：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">button</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"$emit('enlarge-text')"</span>&gt;
<span class="linenr">2: </span>  Enlarge text
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">button</span>&gt;
</pre>
</div>

<hr>
<p>
<b>使用事件抛出一个值</b>
</p>

<p>
有的时候用一个事件来抛出一个特定的值是非常有用的。
</p>

<p>
例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">button</span> <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">click</span>=<span style="color: #50a14f;">"$emit('enlarge-text', 0.1)"</span>&gt;
<span class="linenr">2: </span>  Enlarge text
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">button</span>&gt;
</pre>
</div>

<p>
然后当在 <b>父级组件监听这个事件</b> 的时候，我们 <b>可以通过 <code>$event</code> 访问到被抛出的这个值</b> ：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">blog-post</span>
<span class="linenr">2: </span>  ...
<span class="linenr">3: </span>  <span style="color: #a626a4;">v-on</span>:<span style="color: #6a1868;">enlarge-text</span>=<span style="color: #50a14f;">"postFontSize += $event"</span>
<span class="linenr">4: </span>&gt;&lt;/<span style="color: #a626a4;">blog-post</span>&gt;
</pre>
</div>

<p>
或者，如果这个事件处理函数是 <b>一个方法</b> ，那么这个值将会 <b>作为第一个参数传入这个方法</b> ：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&lt;blog-post</span>
<span class="linenr"> 2: </span><span style="color: #9ca0a4;">//   </span><span style="color: #9ca0a4;">...</span>
<span class="linenr"> 3: </span><span style="color: #9ca0a4;">//   </span><span style="color: #9ca0a4;">v-on:enlarge-text="onEnlargeText"</span>
<span class="linenr"> 4: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">&gt;&lt;/blog-post&gt;</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>methods: <span style="color: #4078f2;">{</span>
<span class="linenr"> 7: </span>  <span style="color: #a626a4;">onEnlargeText</span>: <span style="color: #e45649;">function</span> <span style="color: #a626a4;">(</span><span style="color: #6a1868;">enlargeAmount</span><span style="color: #a626a4;">)</span> <span style="color: #a626a4;">{</span>
<span class="linenr"> 8: </span>    <span style="color: #b751b6;">this</span>.postFontSize += enlargeAmount
<span class="linenr"> 9: </span>  <span style="color: #a626a4;">}</span>
<span class="linenr">10: </span><span style="color: #4078f2;">}</span>
<span class="linenr">11: </span><span style="color: #9ca0a4;">// </span><span style="color: #9ca0a4;">`enlargeAmount` &#23601;&#26159;&#32452;&#20214;&#25243;&#20986;&#26469;&#30340;&#20540;</span>
</pre>
</div>

<hr>
<p>
<b>通过插槽分发内容</b>
</p>

<p>
和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">alert-box</span>&gt;
<span class="linenr">2: </span>  Something bad happened.
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">alert-box</span>&gt;
</pre>
</div>

<p>
幸好，Vue 自定义的 &lt;slot&gt; 元素让这变得非常简单：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>Vue.component<span style="color: #4078f2;">(</span><span style="color: #50a14f;">'alert-box'</span>, <span style="color: #a626a4;">{</span>
<span class="linenr">2: </span>  template: <span style="color: #50a14f;">`</span>
<span class="linenr">3: </span><span style="color: #50a14f;">    &lt;div class="demo-alert-box"&gt;</span>
<span class="linenr">4: </span><span style="color: #50a14f;">      &lt;strong&gt;Error!&lt;/strong&gt;</span>
<span class="linenr">5: </span><span style="color: #50a14f;">      &lt;slot&gt;&lt;/slot&gt;</span>
<span class="linenr">6: </span><span style="color: #50a14f;">    &lt;/div&gt;</span>
<span class="linenr">7: </span><span style="color: #50a14f;">  `</span>
<span class="linenr">8: </span><span style="color: #a626a4;">}</span><span style="color: #4078f2;">)</span>
</pre>
</div>

<hr>
<p>
<b>动态组件</b>
</p>

<p>
在不同组件之间进行动态切换是非常有用的，可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现，如：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span><span style="color: #9ca0a4;">&lt;!-- </span><span style="color: #9ca0a4;">&#32452;&#20214;&#20250;&#22312; `currentTabComponent` &#25913;&#21464;&#26102;&#25913;&#21464; </span><span style="color: #9ca0a4;">--&gt;</span>
<span class="linenr">2: </span>&lt;<span style="color: #a626a4;">component</span> <span style="color: #a626a4;">v-bind</span>:<span style="color: #6a1868;">is</span>=<span style="color: #50a14f;">"currentTabComponent"</span>&gt;&lt;/<span style="color: #a626a4;">component</span>&gt;
</pre>
</div>

<p>
*？请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <code>.prop</code> 修饰器。
</p>

<p>
有些 HTML 元素，诸如 <code>&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;</code> 和 <code>&lt;select&gt;</code> ，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;、&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code> ，只能出现在其它某些特定的元素内部。
</p>

<p>
这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">table</span>&gt;
<span class="linenr">2: </span>  &lt;<span style="color: #a626a4;">blog-post-row</span>&gt;&lt;/<span style="color: #a626a4;">blog-post-row</span>&gt;
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">table</span>&gt;
</pre>
</div>

<p>
这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 <code>is</code> attribute 给了我们一个变通的办法：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr">1: </span>&lt;<span style="color: #a626a4;">table</span>&gt;
<span class="linenr">2: </span>  &lt;<span style="color: #a626a4;">tr</span> <span style="color: #6a1868;">is</span>=<span style="color: #50a14f;">"blog-post-row"</span>&gt;&lt;/<span style="color: #a626a4;">tr</span>&gt;
<span class="linenr">3: </span>&lt;/<span style="color: #a626a4;">table</span>&gt;
</pre>
</div>

<p>
需要注意的是 <b>如果我们从以下来源使用模板的话，这条限制是不存在的：</b>
</p>
<ul class="org-ul">
<li>字符串 (例如： <code>template: '...'</code> )</li>
<li>单文件组件 (<code>.vue</code>)</li>
<li><code>&lt;script type="text/x-template"&gt;</code></li>
</ul>

<p>
到这里，你需要了解的解析 DOM 模板时的注意事项——实际上也是 Vue 的全部必要内容，大概就是这些了。恭喜你！
</p>
</div>
</div>
</div>

<div id="outline-container-orgcd455de" class="outline-2">
<h2 id="orgcd455de">深入了解组件</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-03-17 Wed 16:21</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2021-03-17 Wed 19:41</p>
<p class="validation"><a href="http://beian.miit.gov.cn/">豫ICP备19025929号</a></p>
</div>
</body>
</html>
